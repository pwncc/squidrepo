{
  {
    "howl",
    "local loading = {}\
local oldRequire, preload, loaded = require, {}, { startup = loading }\
\
local function require(name)\
\009local result = loaded[name]\
\
\009if result ~= nil then\
\009\009if result == loading then\
\009\009\009error(\"loop or previous error loading module '\" .. name .. \"'\", 2)\
\009\009end\
\
\009\009return result\
\009end\
\
\009loaded[name] = loading\
\009local contents = preload[name]\
\009if contents then\
\009\009result = contents(name)\
\009elseif oldRequire then\
\009\009result = oldRequire(name)\
\009else\
\009\009error(\"cannot load '\" .. name .. \"'\", 2)\
\009end\
\
\009if result == nil then result = true end\
\009loaded[name] = result\
\009return result\
end\
preload[\"howl.tasks.Task\"] = function(...)\
--- The main task class\
-- @classmod howl.tasks.Task\
\
local assert = require \"howl.lib.assert\"\
local class = require \"howl.class\"\
local colored = require \"howl.lib.colored\"\
local mixin = require \"howl.class.mixin\"\
local os = require \"howl.platform\".os\
local utils = require \"howl.lib.utils\"\
\
local insert = table.insert\
\
--- Convert a pattern\
local function parsePattern(from, to)\
\009local fromParsed = utils.parsePattern(from, true)\
\009local toParsed = utils.parsePattern(to)\
\
\009local newType = fromParsed.Type\
\009assert(newType == toParsed.Type, \"Both from and to must be the same type \" .. newType .. \" and \" .. fromParsed.Type)\
\
\009return { Type = newType, From = fromParsed.Text, To = toParsed.Text }\
end\
\
local Task = class(\"howl.tasks.Task\")\
\009:include(mixin.configurable)\
\009:include(mixin.optionGroup)\
\009:addOptions { \"description\" }\
\
--- Create a task\
-- @tparam string name The name of the task\
-- @tparam table dependencies A list of tasks this task requires\
-- @tparam function action The action to run\
-- @treturn Task The created task\
function Task:initialize(name, dependencies, action)\
\009assert.argType(name, \"string\", \"Task\", 1)\
\
\009-- Check calling with no dependencies\
\009if type(dependencies) == \"function\" then\
\009\009action = dependencies\
\009\009dependencies = {}\
\009end\
\
\009self.options = {}\
\009self.name = name -- The name of the function\
\009self.action = action -- The action to call\
\009self.dependencies = {} -- Task dependencies\
\009self.maps = {} -- Reads and produces list\
\009self.produces = {} -- Files this task produces\
\
\009if dependencies then self:depends(dependencies) end\
end\
\
function Task.static:addDependency(class, name)\
\009local function apply(self, ...)\
\009\009if select('#', ...) == 1 and type(...) == \"table\" and (#(...) > 0 or next(...) == nil) then\
\009\009\009local first = ...\
\009\009\009for i = 1, #first do\
\009\009\009\009insert(self.dependencies, class(self, first[i]))\
\009\009\009end\
\009\009else\
\009\009\009insert(self.dependencies, class(self, ...))\
\009\009end\
\
\009\009return self\
\009end\
\
\009self[name] = apply\
\009self[name:gsub(\"^%l\", string.upper)] = apply\
\
\009return self\
end\
\
function Task:setup(context, runner) end\
\
--- Sets a file this task produces\
-- @tparam string|table file The path of the file\
-- @treturn Task The current object (allows chaining)\
function Task:Produces(file)\
\009if type(file) == \"table\" then\
\009\009local produces = self.produces\
\009\009for _, file in ipairs(file) do\
\009\009\009table.insert(produces, file)\
\009\009end\
\009else\
\009\009table.insert(self.produces, file)\
\009end\
\009return self\
end\
\
--- Sets a file mapping\
-- @tparam string from The file to map form\
-- @tparam string to The file to map to\
-- @treturn Task The current object (allows chaining)\
function Task:Maps(from, to)\
\009table.insert(self.maps, parsePattern(from, to))\
\009return self\
end\
\
--- Set the action for this task\
-- @tparam function action The action to run\
-- @treturn Task The current object (allows chaining)\
function Task:Action(action)\
\009self.action = action\
\009return self\
end\
\
--- Run the action with no bells or whistles\
function Task:runAction(context, ...)\
\009if self.action then\
\009\009return self.action(self, context, ...)\
\009else\
\009\009return true\
\009end\
end\
\
--- Execute the task\
-- @tparam Context.Context context The task context\
-- @param ... The arguments to pass to task\
-- @tparam boolean Success\
function Task:Run(context, ...)\
\009local shouldRun = false\
\009if #self.dependencies == 0 then\
\009\009shouldRun = true\
\009else\
\009\009for _, depends in ipairs(self.dependencies) do\
\009\009\009if depends:resolve(context.env, context) then\
\009\009\009\009shouldRun = true\
\009\009\009end\
\009\009end\
\009end\
\
\009if not shouldRun then return false end\
\
\009for _, file in ipairs(self.produces) do\
\009\009context.filesProduced[file] = true\
\009end\
\
\009-- Technically we don't need to specify an action\
\009local args = { ... }\
\009local description = \"\"\
\
\009-- Get a list of arguments\
\009if #args > 0 then\
\009\009local newArgs = {}\
\009\009for _, arg in ipairs(args) do\
\009\009\009table.insert(newArgs, tostring(arg))\
\009\009end\
\009\009description = \" (\" .. table.concat(newArgs, \", \") .. \")\"\
\009end\
\009context.env.logger:info(\"Running %s\", self.name .. description)\
\
\009local oldTime = os.clock()\
\009local s, err = true, nil\
\009if context.Traceback then\
\009\009xpcall(function() self:runAction(context.env, unpack(args)) end, function(msg)\
\009\009\009for i = 5, 15 do\
\009\009\009\009local _, err = pcall(function() error(\"\", i) end)\
\009\009\009\009if msg:match(\"Howlfile\") then break end\
\009\009\009\009msg = msg .. \"\\n  \" .. err\
\009\009\009end\
\
\009\009\009err = msg\
\009\009\009s = false\
\009\009end)\
\009else\
\009\009s, err = pcall(self.runAction, self, context.env, ...)\
\009end\
\
\009if s then\
\009\009context.env.logger:success(\"%s finished\", self.name)\
\009else\
\009\009context.env.logger:error(\"%s: %s\", self.name, err or \"no message\")\
\009\009error(\"Error running tasks\", 0)\
\009end\
\
\009if context.ShowTime then\
\009\009print(\" \", \"Took \" .. os.clock() - oldTime .. \"s\")\
\009end\
\
\009return true\
end\
\
return Task\
end\
preload[\"howl.tasks.Runner\"] = function(...)\
--- Handles tasks and dependencies\
-- @classmod howl.tasks.Runner\
\
local class = require \"howl.class\"\
local colored = require \"howl.lib.colored\"\
local Context = require \"howl.tasks.Context\"\
local mixin = require \"howl.class.mixin\"\
local os = require \"howl.platform\".os\
local Task = require \"howl.tasks.Task\"\
\
--- Handles a collection of tasks and running them\
-- @type Runner\
local Runner = class(\"howl.tasks.Runner\"):include(mixin.sealed)\
\
--- Create a @{Runner} object\
-- @tparam env env The current environment\
-- @treturn Runner The created runner object\
function Runner:initialize(env)\
\009self.tasks = {}\
\009self.default = nil\
\009self.env = env\
end\
\
function Runner:setup()\
\009for _, task in pairs(self.tasks) do\
\009\009task:setup(self.env, self)\
\009end\
\
\009if self.env.logger.hasError then return false end\
\
\009for _, task in pairs(self.tasks) do\
\009\009for _, dependency in ipairs(task.dependencies) do\
\009\009\009dependency:setup(self.env, self)\
\009\009end\
\009end\
\
\009if self.env.logger.hasError then return false end\
\009return true\
end\
\
--- Create a task\
-- @tparam string name The name of the task to create\
-- @treturn function A builder for tasks\
function Runner:Task(name)\
\009return function(dependencies, action) return self:addTask(name, dependencies, action) end\
end\
\
--- Add a task to the collection\
-- @tparam string name The name of the task to add\
-- @tparam table dependencies A list of tasks this task requires\
-- @tparam function action The action to run\
-- @treturn Task The created task\
function Runner:addTask(name, dependencies, action)\
\009return self:injectTask(Task(name, dependencies, action))\
end\
\
--- Add a Task object to the collection\
-- @tparam Task task The task to insert\
-- @tparam string name The name of the task (optional)\
-- @treturn Task The current task\
function Runner:injectTask(task, name)\
\009self.tasks[name or task.name] = task\
\009return task\
end\
\
--- Set the default task\
-- @tparam ?|string|function task The task to run or the name of the task\
-- @treturn Runner The current object for chaining\
function Runner:Default(task)\
\009local defaultTask\
\009if task == nil then\
\009\009self.default = nil\
\009elseif type(task) == \"string\" then\
\009\009self.default = self.tasks[task]\
\009\009if not self.default then\
\009\009\009error(\"Cannot find task \" .. task)\
\009\009end\
\009else\
\009\009self.default = Task(\"<default>\", {}, task)\
\009end\
\
\009return self\
end\
\
--- Run a task, and all its dependencies\
-- @tparam string name Name of the task to run\
-- @treturn Runner The current object for chaining\
function Runner:Run(name)\
\009return self:RunMany({ name })\
end\
\
--- Run a task, and all its dependencies\
-- @tparam table names Names of the tasks to run\
-- @return The result of the last task\
function Runner:RunMany(names)\
\009local oldTime = os.clock()\
\009local value = true\
\
\009local context = Context(self)\
\009if #names == 0 then\
\009\009context:Start()\
\009else\
\009\009for _, name in ipairs(names) do\
\009\009\009value = context:Start(name)\
\009\009end\
\009end\
\
\009if context.ShowTime then\
\009\009colored.printColor(\"orange\", \"Took \" .. os.clock() - oldTime .. \"s in total\")\
\009end\
\
\009return value\
end\
\
return Runner\
end\
preload[\"howl.tasks.OptionTask\"] = function(...)\
--- A Task that can store options\
-- @classmod howl.tasks.OptionTask\
\
local assert = require \"howl.lib.assert\"\
local mixin = require \"howl.class.mixin\"\
local rawset = rawset\
\
local Task = require \"howl.tasks.Task\"\
\
local OptionTask = Task:subclass(\"howl.tasks.OptionTask\")\
\009:include(mixin.configurable)\
\
function OptionTask:initialize(name, dependencies, keys, action)\
\009Task.initialize(self, name, dependencies, action)\
\
\009self.options = {}\
\009self.optionKeys = {}\
\009for _, key in ipairs(keys or {}) do\
\009\009self:addOption(key)\
\009end\
end\
\
function OptionTask:addOption(key)\
\009local options = self.options\
\009local func = function(self, value)\
\009\009if value == nil then value = true end\
\009\009options[key] = value\
\009\009return self\
\009end\
\
\009self[key:gsub(\"^%l\", string.upper)] = func\
\009self[key] = func\
\009self.optionKeys[key] = true\
end\
\
function OptionTask:configure(item)\
\009assert.argType(item, \"table\", \"configure\", 1)\
\
\009for k, v in pairs(item) do\
\009\009if self.optionKeys[k] then\
\009\009\009self.options[k] = v\
\009\009else\
\009\009\009-- TODO: Configure filtering\
\009\009\009-- error(\"Unknown option \" .. tostring(k), 2)\
\009\009end\
\009end\
end\
\
return OptionTask\
end\
preload[\"howl.tasks.Dependency\"] = function(...)\
--- An abstract class dependency\
-- @classmod howl.tasks.Dependency\
\
local class = require \"howl.class\"\
\
local Dependency = class(\"howl.tasks.Dependency\")\
\
--- Create a new dependency\
function Dependency:initialize(task)\
\009if self.class == Dependency then\
\009\009error(\"Cannot create instance of abstract class \" .. tostring(Dependency), 2)\
\009end\
\
\009self.task = task\
end\
\
--- Setup the dependency, checking if it cannot be resolved\
function Dependency:setup(context, runner)\
\009error(\"setup has not been overridden in \" .. self.class, 2)\
end\
\
--- Execute the dependency\
-- @treturn boolean If the task was run\
function Dependency:resolve(context, runner)\
\009error(\"resolve has not been overridden in \" .. self.class, 2)\
end\
\
return Dependency\
end\
preload[\"howl.tasks.Context\"] = function(...)\
--- Manages the running of tasks\
-- @classmod howl.tasks.Context\
\
local class = require \"howl.class\"\
local fs = require \"howl.platform\".fs\
local mixin = require \"howl.class.mixin\"\
local platform = require \"howl.platform\"\
\
--- Holds task contexts\
local Context = class(\"howl.tasks.Context\"):include(mixin.sealed)\
\
--- Create a new task context\
-- @tparam Runner.Runner runner The task runner to run tasks from\
-- @treturn Context The resulting context\
function Context:initialize(runner)\
\009self.ran = {} -- List of task already run\
\009self.filesProduced = {}\
\009self.tasks = runner.tasks\
\009self.default = runner.default\
\
\009self.Traceback = runner.Traceback\
\009self.ShowTime = runner.ShowTime\
\009self.env = runner.env\
\009self:BuildCache()\
end\
\
function Context:DoRequire(path, quite)\
\009if self.filesProduced[path] then return true end\
\
\009-- Check for normal files\
\009local task = self.producesCache[path]\
\009if task then\
\009\009self.filesProduced[path] = true\
\009\009return self:Run(task)\
\009end\
\
\009-- Check for file mapping\
\009task = self.normalMapsCache[path]\
\009local from, name\
\009local to = path\
\009if task then\
\009\009self.filesProduced[path] = true\
\
\009\009-- Convert task.Pattern.From to path\
\009\009-- (which should be task.Pattern.To)\
\009\009name = task.Name\
\009\009from = task.Pattern.From\
\009end\
\
\009for match, data in pairs(self.patternMapsCache) do\
\009\009if path:match(match) then\
\009\009\009self.filesProduced[path] = true\
\
\009\009\009-- Run task, replacing match with the replacement pattern\
\009\009\009name = data.Name\
\009\009\009from = path:gsub(match, data.Pattern.From)\
\009\009\009break\
\009\009end\
\009end\
\
\009if name then\
\009\009local canCreate = self:DoRequire(from, true)\
\009\009if not canCreate then\
\009\009\009if not quite then\
\009\009\009\009self.env.logger:error(\"Cannot find '\" .. from .. \"'\")\
\009\009\009end\
\009\009\009return false\
\009\009end\
\
\009\009return self:Run(name, from, to)\
\009end\
\
\009if fs.exists(fs.combine(self.env.root, path)) then\
\009\009self.filesProduced[path] = true\
\009\009return true\
\009end\
\
\009if not quite then\
\009\009self.env.logger:error(\"Cannot find a task matching '\" .. path .. \"'\")\
\009end\
\009return false\
end\
\
local function arrayEquals(x, y)\
\009local len = #x\
\009if #x ~= #y then return false end\
\
\009for i = 1, len do\
\009\009if x[i] ~= y[i] then return false end\
\009end\
\009return true\
end\
\
--- Run a task\
-- @tparam string|Task.Task name The name of the task or a Task object\
-- @param ... The arguments to pass to it\
-- @treturn boolean Success in running the task?\
function Context:Run(name, ...)\
\009local task = name\
\009if type(name) == \"string\" then\
\009\009task = self.tasks[name]\
\
\009\009if not task then\
\009\009\009error(\"Cannot find a task called '\" .. name .. \"'\")\
\009\009\009return false\
\009\009end\
\009elseif not task or not task.Run then\
\009\009error(\"Cannot call task \" .. tostring(task) .. \" as it has no 'Run' method\")\
\009\009return false\
\009end\
\
\009-- Search if this task has been run with the given arguments\
\009local args = { ... }\
\009local ran = self.ran[task]\
\009if not ran then\
\009\009ran = { args }\
\009\009self.ran[task] = ran\
\009else\
\009\009for i = 1, #ran do\
\009\009\009if arrayEquals(args, ran[i]) then return false end\
\009\009end\
\009\009ran[#ran + 1] = args\
\009end\
\
\009-- Sleep before every task just in case\
\009platform.refreshYield()\
\
\009return task:Run(self, ...)\
end\
\
Context.run = Context.Run\
\
--- Start the task process\
-- @tparam string name The name of the task (Optional)\
-- @treturn boolean Success in running the task?\
function Context:Start(name)\
\009local task\
\009if name then\
\009\009task = self.tasks[name]\
\009else\
\009\009task = self.default\
\009\009name = \"<default>\"\
\009end\
\
\009if not task then\
\009\009self.env.logger:error(\"Cannot find a task called '\" .. name .. \"'\")\
\009\009return false\
\009end\
\
\009return self:Run(task)\
end\
\
--- Build a cache of tasks\
-- This is used to speed up finding file based tasks\
-- @treturn Context The current context\
function Context:BuildCache()\
\009local producesCache = {}\
\009local patternMapsCache = {}\
\009local normalMapsCache = {}\
\
\009self.producesCache = producesCache\
\009self.patternMapsCache = patternMapsCache\
\009self.normalMapsCache = normalMapsCache\
\
\009for name, task in pairs(self.tasks) do\
\009\009local produces = task.produces\
\009\009if produces then\
\009\009\009for _, file in ipairs(produces) do\
\009\009\009\009local existing = producesCache[file]\
\009\009\009\009if existing then\
\009\009\009\009\009error(string.format(\"Both '%s' and '%s' produces '%s'\", existing, name, file))\
\009\009\009\009end\
\009\009\009\009producesCache[file] = name\
\009\009\009end\
\009\009end\
\
\009\009local maps = task.maps\
\009\009if maps then\
\009\009\009for _, pattern in ipairs(maps) do\
\009\009\009\009-- We store two separate caches for each of them\
\009\009\009\009local toMap = (pattern.Type == \"Pattern\" and patternMapsCache or normalMapsCache)\
\009\009\009\009local match = pattern.To\
\009\009\009\009local existing = toMap[match]\
\009\009\009\009if existing then\
\009\009\009\009\009error(string.format(\"Both '%s' and '%s' match '%s'\", existing, name, match))\
\009\009\009\009end\
\009\009\009\009toMap[match] = { Name = name, Pattern = pattern }\
\009\009\009end\
\009\009end\
\009end\
\
\009return self\
end\
\
return Context\
end\
preload[\"howl.scratchpad\"] = function(...)\
local utils = require \"howl.lib.utils\"\
local dump = require \"howl.lib.dump\".dump\
local printColor = require \"howl.lib.colored\".printColor\
\
local parsePattern = utils.parsePattern\
local createLookup = utils.createLookup\
\
local tasks = {\
\009{\
\009\009name = \"input\",\
\009\009provides = createLookup { \"foo.un.lua\" },\
\009},\
\
\009{\
\009\009name = \"output\",\
\009\009requires = createLookup { \"foo.min.lua\" },\
\009},\
\
\009{\
\009\009name = \"minify\",\
\009\009maps = {\
\009\009\009{\
\009\009\009\009from = parsePattern(\"wild:*.lua\", true),\
\009\009\009\009to = parsePattern(\"wild:*.min.lua\")\
\009\009\009}\
\009\009},\
\009},\
\
\009{\
\009\009name = \"licence\",\
\009\009maps = {\
\009\009\009{\
\009\009\009\009from = parsePattern(\"wild:*.un.lua\", true),\
\009\009\009\009to = parsePattern(\"wild:*.lua\")\
\009\009\009}\
\009\009},\
\009},\
}\
\
for k, v in pairs(tasks) do\
\009tasks[v.name] = v\
\009if not v.maps then v.maps = {} end\
\009v.mapper = #v.maps > 0\
\009if not v.provides then v.provides = {} end\
\009if not v.requires then v.requires = {} end\
end\
\
local function matching(name)\
\009local out = {}\
\
\009for _, task in ipairs(tasks) do\
\009\009if task.provides[name] then\
\009\009\009out[#out + 1] = { task = task.name }\
\009\009end\
\
\009\009for _, mapping in ipairs(task.maps) do\
\009\009\009if mapping.to.Type == \"Text\" then\
\009\009\009\009if mapping.to.Text == name then\
\009\009\009\009\009out[#out + 1] = {\
\009\009\009\009\009\009task = task.name,\
\009\009\009\009\009\009mapping.from.Text,\
\009\009\009\009\009\009name\
\009\009\009\009\009}\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009if name:find(mapping.to.Text) then\
\009\009\009\009\009out[#out + 1] = {\
\009\009\009\009\009\009task = task.name,\
\009\009\009\009\009\009name:gsub(mapping.to.Text, mapping.from.Text),\
\009\009\009\009\009\009name\
\009\009\009\009\009}\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\
\009return out\
end\
\
local function resolveTasks(...)\
\009local out = {}\
\
\009local queue = {}\
\
\009local depCache = {}\
\009local function addDep(dependency, depth)\
\009\009local hash = dependency.task .. \"|\"..table.concat(dependency, \"|\")\
\
\009\009local existing = depCache[hash]\
\009\009if existing then\
\009\009\009existing.depth = math.min(existing.depth, depth)\
\009\009\009return existing\
\009\009else\
\009\009\009dependency.depth = depth\
\009\009\009dependency.needed = {}\
\009\009\009dependency.solutions = {}\
\009\009\009dependency.name = dependency.task .. \": \" .. table.concat(dependency, \" \\26 \")\
\009\009\009depCache[hash] = dependency\
\009\009\009queue[#queue + 1] = dependency\
\009\009\009return dependency\
\009\009end\
\009end\
\
\009local function addSolution(solution, dependency)\
\009\009local solution = addDep(solution, dependency.depth + 1)\
\009\009solution.needed[#solution.needed + 1] = dependency\
\
\009\009return solution\
\009end\
\
\009for i = 1, select('#', ...) do\
\009\009addDep({ task = select(i, ...)}, 1)\
\009end\
\
\009while #queue > 0 do\
\009\009local dependency = table.remove(queue, 1)\
\009\009local task = tasks[dependency.task]\
\
\009\009print(\"Task '\" .. dependency.name)\
\009\009if #dependency.needed > 0 then\
\009\009\009print(\"  Needed for\")\
\009\009\009for i = 1, #dependency.needed do\
\009\009\009\009printColor(\"lightGrey\", \"    \" .. dependency.needed[i].name)\
\009\009\009end\
\009\009end\
\
\009\009if dependency.depth > 4 then\
\009\009\009printColor(\"red\", \"  Too deep\")\
\009\009elseif #dependency.solutions > 0 or (#task.requires == 0 and not task.mapper) then\
\009\009\009printColor(\"green\", \"  Endpoint\")\
\009\009\009out[#out + 1] = dependency\
\
\009\009\009for i = 1, #dependency.needed do\
\009\009\009\009local needed = dependency.needed[i]\
\009\009\009\009needed.solutions[#needed.solutions + 1] = dependency\
\
\009\009\009\009-- This should only happen once everything has happened\
\009\009\009\009if #needed.solutions == 1 then\
\009\009\009\009\009queue[#queue + 1] = needed\
\009\009\009\009end\
\009\009\009end\
\009\009else\
\009\009\009for i = 1, #task.requires do\
\009\009\009\009local requirement = task.requires[i]\
\009\009\009\009print(\"  Depends on '\" .. requirement .. \"'\")\
\
\009\009\009\009local matching = matching(requirement)\
\009\009\009\009for i = 1, #matching do\
\009\009\009\009\009local solution = addSolution(matching[i], dependency)\
\
\009\009\009\009\009printColor(\"yellow\", \"    Maybe: \" .. solution.name)\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009if task.mapper then\
\009\009\009\009local requirement = dependency[1]\
\009\009\009\009print(\"  Depends on '\" .. requirement .. \"'\")\
\
\009\009\009\009local matching = matching(requirement)\
\009\009\009\009for i = 1, #matching do\
\009\009\009\009\009local solution = addSolution(matching[i], dependency)\
\
\009\009\009\009\009printColor(\"yellow\", \"    Maybe: \" .. solution.name)\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009end\
\
\009return out\
end\
\
-- print(dump(tasks))\
-- print(\"Resolved\", dump(matching(\"foo.min.lua\")))\
\
\
local resolved = resolveTasks(\"output\")\
for i = 1, #resolved do\
\009print(resolved[i].name)\
end\
end\
preload[\"howl.platform.oc\"] = function(...)\
--- OpenComputers's platform table\
-- @module howl.platform.oc\
\
local filesystem = require(\"filesystem\")\
local term = require(\"term\")\
local component = require(\"component\")\
local hasInternet = pcall(function() return component.internet end)\
local internet = require(\"internet\")\
local gpu = component.gpu\
\
local function read(filename)\
\009local size = getSize(filename)\
\009local fh = filesystem.open(filename)\
\009local contents = fh:read(size)\
\009fh:close()\
\009return contents\
end\
\
--readDir and writeDir copied semi-verbatim from CC platform (with a slight modification)\
local function readDir(directory)\
\009local offset = #directory + 2\
\009local stack, n = { directory }, 1\
\
\009local files = {}\
\
\009while n > 0 do\
\009\009local top = stack[n]\
\009\009n = n - 1\
\
\009\009if fs.isDir(top) then\
\009\009\009for _, file in ipairs(filesystem.list(top)) do\
\009\009\009\009n = n + 1\
\009\009\009\009stack[n] = filesystem.combine(top, file)\
\009\009\009end\
\009\009else\
\009\009\009files[top:sub(offset)] = read(top)\
\009\009end\
\009end\
\
\009return files\
end\
\
local function writeDir(dir, files)\
\009for file, contents in pairs(files) do\
\009\009write(filesystem.combine(dir, file), contents)\
\009end\
end\
\
local function write(filename,contents)\
\009local fh = filesystem.open(filename,\"w\")\
\009local ok, err = fh:write(contents)\
\009if not ok then io.stderr:write(err) end\
\009fh:close()\
end\
\
local function assertExists(file,name,level)\
\009if not filesystem.exists(file) then\
\009\009error(\"Cannot find \"..name..\" (looking for \"..file..\")\",level or 1)\
\009end\
end\
\
local function getSize(file)\
\009local fh = filesystem.open(file)\
\009local size = fh:seek(\"end\")\
\009fh:close()\
\009return size\
end\
\
local function request(url,post,headers)\
\009if not hasInternet then error(\"No internet card found\",0) end\
\009\009local resp = \"\"\
\009for chunk in internet.request(url,post,headers) do\
\009\009resp = resp..chunk\
\009end\
\009return resp\
end\
\
local function notImplemented(name)\
\009return function() error(name..\" has not been implemented for OpenComputers!\",2) end\
end\
\
return {\
\009os = {\
\009\009clock = os.clock,\
\009\009time = os.time,\
\009\009getEnv = os.getEnv,\
\009},\
\009fs = {\
\009\009-- Path manipulation\
\009\009combine = filesystem.concat,\
\009\009normalise = filesystem.canonical,\
\009\009getDir = filesystem.path,\
\009\009getName = filesystem.name,\
\009\009currentDir = shell.getWorkingDirectory,\
\009\009currentProgram = function() return process.info().command end,\
\
\009\009-- File access\
\009\009read = read,\
\009\009write = write,\
\009\009readDir = readDir,\
\009\009writeDir = writeDir,\
\009\009getSize = getSize,\
\
\009\009-- Type checking\
\009\009assertExists = assertExists,\
\009\009exists = filesystem.exists,\
\009\009isDir = filesystem.isDir,\
\
\009\009-- Other\
\009\009list = filesystem.list,\
\009\009makeDir = filesystem.makeDir,\
\009\009delete = filesystem.delete,\
\009\009move = filesystem.move,\
\009\009copy = filesystem.copy,\
\009},\
\009term = {\
\009\009setColor = gpu.setForeground,\
\009\009resetColor = function() gpu.setForeground(colors.white) end,\
\
\009\009print = print,\
\009\009write = io.write,\
\009},\
\009http = {\
\009\009request = request,\
\009},\
\009log = function() return end,\
\
\009refreshYield = function() os.sleep(0) end,\
}\
end\
preload[\"howl.platform.native\"] = function(...)\
--- Platform implementation for vanilla Lua\
-- @module howl.platform.native\
\
local escapeBegin = string.char(27) .. '['\
local colorMappings = {\
\009white     = 97,\
\009orange    = 33,\
\009magenta   = 95,\
\009lightBlue = 94,\
\009yellow    = 93,\
\009lime      = 92,\
\009pink      = 95, -- No pink\
\009gray      = 90, grey = 90,\
\009lightGray = 37, lightGrey = 37,\
\009cyan      = 96,\
\009purple    = 35, -- Dark magenta\
\009blue      = 36,\
\009brown     = 31,\
\009green     = 32,\
\009red       = 91,\
\009black     = 30,\
}\
\
local function notImplemented(name)\
\009return function() error(name .. \" is not implemented\", 2) end\
end\
\
local path = require('pl.path')\
local dir = require('pl.dir')\
local file = require('pl.file')\
return {\
\009fs = {\
\009\009combine = path.join,\
\009\009normalise = path.normpath,\
\009\009getDir = path.dirname,\
\009\009getName = path.basename,\
\009\009currentDir = function() return path.currentdir end,\
\
\009\009read = file.read,\
\009\009write = file.write,\
\009\009readDir = notImplemented(\"fs.readDir\"),\
\009\009writeDir = notImplemented(\"fs.writeDir\"),\
\009\009getSize = function(n)\
\009\009\009local file = io:open(n,\"r\")\
\009\009\009local size = file:seek(\"end\")\
\009\009\009file:close()\
\009\009\009return size\
\009\009end,\
\
\009\009assertExists = function(file)\
\009\009\009if not path.exists(file) then\
\009\009\009\009error(\"File does not exist\")\
\009\009\009end\
\009\009end,\
\009\009exists = path.exists,\
\009\009isDir = path.isdir,\
\
\009\009-- Other\
\009\009list = function(dir)\
\009\009\009local result = {}\
\009\009\009for path in path.dir(dir) do\
\009\009\009\009result[#result + 1] = path\
\009\009\009end\
\
\009\009\009return result\
\009\009end,\
\009\009makeDir = dir.makepath,\
\009\009delete = function(pa)\
\009\009\009if path.isdir(pa) then\
\009\009\009\009dir.rmtree(pa)\
\009\009\009else\
\009\009\009\009file.delete(pa)\
\009\009\009end\
\009\009end,\
\009\009move = file.move,\
\009\009copy = file.copy,\
\009},\
\
\009http = {\
\009\009request = notImplemented(\"http.request\"),\
\009},\
\
\009term = {\
\009\009setColor = function(color)\
\009\009\009local col = colorMappings[color]\
\009\009\009if not col then error(\"Cannot find color \" .. tostring(color), 2) end\
\009\009\009io.write(escapeBegin .. col .. \"m\")\
\009\009\009io.flush()\
\009\009end,\
\009\009resetColor = function()\
\009\009\009io.write(escapeBegin .. \"0m\")\
\009\009\009io.flush()\
\009\009end\
\009},\
\009refreshYield = function() end\
}\
end\
preload[\"howl.platform\"] = function(...)\
--- The native loader for platforms\
-- @module howl.platform\
\
if fs and term then\
\009return require \"howl.platform.cc\"\
elseif _G.component then\
\009return require \"howl.platform.oc\"\
else\
\009return require \"howl.platform.native\"\
end\
end\
preload[\"howl.platform.cc\"] = function(...)\
--- CC's platform table\
-- @module howl.platform.cc\
\
local default = term.getTextColor and term.getTextColor() or colors.white\
\
local function read(file)\
\009local handle = fs.open(file, \"r\")\
\009local contents = handle.readAll()\
\009handle.close()\
\009return contents\
end\
\
local function write(file, contents)\
\009local handle = fs.open(file, \"w\")\
\009handle.write(contents)\
\009handle.close()\
end\
\
local function assertExists(file, name, level)\
\009if not fs.exists(file) then\
\009\009error(\"Cannot find \" .. name .. \" (Looking for \" .. file .. \")\", level or 1)\
\009end\
end\
\
local push, pull = os.queueEvent, coroutine.yield\
\
local function refreshYield()\
\009push(\"sleep\")\
\009if pull() == \"terminate\" then error(\"Terminated\") end\
end\
\
local function readDir(directory)\
\009local offset = #directory + 2\
\009local stack, n = { directory }, 1\
\
\009local files = {}\
\
\009while n > 0 do\
\009\009local top = stack[n]\
\009\009n = n - 1\
\
\009\009if fs.isDir(top) then\
\009\009\009for _, file in ipairs(fs.list(top)) do\
\009\009\009\009n = n + 1\
\009\009\009\009stack[n] = fs.combine(top, file)\
\009\009\009end\
\009\009else\
\009\009\009files[top:sub(offset)] = read(top)\
\009\009end\
\009end\
\
\009return files\
end\
\
local function writeDir(dir, files)\
\009for file, contents in pairs(files) do\
\009\009write(fs.combine(dir, file), contents)\
\009end\
end\
\
local request\
if http.fetch then\
\009request = function(url, post, headers)\
\009\009local ok, err = http.fetch(url, post, headers)\
\009\009if ok then\
\009\009\009while true do\
\009\009\009\009local event, param1, param2, param3 = os.pullEvent(e)\
\009\009\009\009if event == \"http_success\" and param1 == url then\
\009\009\009\009\009return true, param2\
\009\009\009\009elseif event == \"http_failure\" and param1 == url then\
\009\009\009\009\009return false, param3, param2\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009return false, nil, err\
\009end\
else\
\009request = function(...)\
\009\009local ok, result = http.post(...)\
\009\009if ok then\
\009\009\009return true, result\
\009\009else\
\009\009\009return false, nil, result\
\009\009end\
\009end\
end\
\
local getEnv\
if settings and fs.exists(\".settings\") then\
\009settings.load(\".settings\")\
end\
\
if settings and shell.getEnv then\
\009getEnv = function(name, default)\
\009\009local value = shell.getEnv(name)\
\009\009if value ~= nil then return value end\
\
\009\009return settings.get(name, default)\
\009end\
elseif settings then\
\009getEnv = settings.get\
elseif shell.getEnv then\
\009getEnv = function(name, default)\
\009\009local value = shell.getEnv(name)\
\009\009if value ~= nil then return value end\
\009\009return default\
\009end\
else\
\009getEnv = function(name, default) return default end\
end\
\
local time\
if profiler and profiler.milliTime then\
\009time = function() return profiler.milliTime() * 1e-3 end\
else\
\009time = os.time\
end\
\
local log\
if howlci then\
\009log = howlci.log\
else\
\009log = function() end\
end\
\
return {\
\009os = {\
\009\009clock = os.clock,\
\009\009time = time,\
\009\009getEnv = getEnv,\
\009},\
\009fs = {\
\009\009-- Path manipulation\
\009\009combine = fs.combine,\
\009\009normalise = function(path) return fs.combine(path, \"\") end,\
\009\009getDir = fs.getDir,\
\009\009getName = fs.getName,\
\009\009currentDir = shell.dir,\
\009\009currentProgram = shell.getRunningProgram,\
\
\009\009-- File access\
\009\009read = read,\
\009\009write = write,\
\009\009readDir = readDir,\
\009\009writeDir = writeDir,\
\009\009getSize = fs.getSize,\
\
\009\009-- Type checking\
\009\009assertExists = assertExists,\
\009\009exists = fs.exists,\
\009\009isDir = fs.isDir,\
\
\009\009-- Other\
\009\009list = fs.list,\
\009\009makeDir = fs.makeDir,\
\009\009delete = fs.delete,\
\009\009move = fs.move,\
\009\009copy = fs.copy,\
\009},\
\009term = {\
\009\009setColor = function(color)\
\009\009\009local col = colours[color] or colors[color]\
\009\009\009if not col then error(\"Unknown color \" .. color, 2) end\
\
\009\009\009term.setTextColor(col)\
\009\009end,\
\009\009resetColor = function() term.setTextColor(default) end,\
\
\009\009print = print,\
\009\009write = io.write,\
\009},\
\009http = {\
\009\009request = request,\
\009},\
\009log = log,\
\
\009refreshYield = refreshYield,\
}\
end\
preload[\"howl.packages.Proxy\"] = function(...)\
--- A proxy to a package\
-- @classmod howl.packages.Proxy\
\
local class = require \"howl.class\"\
local fs = require \"howl.platform\".fs\
local mixin = require \"howl.class.mixin\"\
\
local Proxy = class(\"howl.packages.Proxy\")\
\
--- Create a new package\
function Proxy:initialize(manager, name, package)\
\009self.name = name\
\009self.manager = manager\
\009self.package = package\
end\
\
--- Get a unique name for this package\
-- @treturn string The unique name\
function Proxy:getName()\
\009return self.name\
end\
\
--- Get the files for a set of metadata\
-- @treturn table Lookup of provided files to actual path. They should not have a leading '/'.\
function Proxy:files()\
\009local cache = self.manager:getCache(self.name)\
\009return self.package:files(cache)\
end\
\
--- Resolve this package, fetching if required\
-- @tparam [string] files List of required files\
-- @tparam boolean force Force a refresh of dependencies\
-- @return The list of files within the package\
function Proxy:require(files, force)\
\009return self.manager:require(self.package, files, force)\
end\
\
return Proxy\
end\
preload[\"howl.packages.Package\"] = function(...)\
--- An abstract package\
-- @classmod howl.packages.Package\
\
local class = require \"howl.class\"\
local fs = require \"howl.platform\".fs\
local mixin = require \"howl.class.mixin\"\
\
local Package = class(\"howl.packages.Package\")\
\009:include(mixin.configurable)\
\009:include(mixin.optionGroup)\
\
--- Create a new package\
function Package:initialize(context, root)\
\009if self.class == Package then\
\009\009error(\"Cannot create instance of abstract class \" .. tostring(Package), 2)\
\009end\
\
\009self.context = context\
\009self.root = root\
\009self.options = {}\
end\
\
--- Setup the package, checking if it is well formed\
function Package:setup()\
\009error(\"setup has not been overridden in \" .. tostring(self.class), 2)\
end\
\
--- Get a unique name for this package\
-- @treturn string The unique name\
function Package:getName()\
\009error(\"name has not been overridden in \" .. tostring(self.class), 2)\
end\
\
--- Get the files for a set of metadata\
-- @param cache The previous cache metadata\
-- @treturn table Lookup of provided files to actual path. They should not have a leading '/'.\
function Package:files(cache)\
\009error(\"files has not been overridden in \" .. tostring(self.class), 2)\
end\
\
--- Resolve this package, fetching if required\
-- @param previous The previous cache metadata\
-- @tparam boolean refresh Force a refresh of dependencies\
-- @return The new cache metadata\
function Package:require(previous, refresh)\
\009error(\"require has not been overrriden in \" .. tostring(self.class), 2)\
end\
\
return Package\
end\
preload[\"howl.packages.Manager\"] = function(...)\
--- Handles external packages\
-- @module howl.packages.Manager\
\
local class = require \"howl.class\"\
local fs = require \"howl.platform\".fs\
local dump = require \"howl.lib.dump\"\
local mixin = require \"howl.class.mixin\"\
\
local Proxy = require \"howl.packages.Proxy\"\
\
local emptyCache = {}\
\
local Manager = class(\"howl.packages.Manager\")\
Manager.providers = {}\
\
function Manager:initialize(context)\
\009self.context = context\
\
\009self.packages = {}\
\009self.packageLookup = {}\
\009self.cache = {}\
\009self.root = \".howl/packages\"\
\009self.alwaysRefresh = false\
end\
\
function Manager.static:addProvider(class, name)\
\009self.providers[name] = class\
end\
\
function Manager:addPackage(type, details)\
\009local provider = Manager.providers[type]\
\009if not provider then error(\"No such package provider \" .. type, 2) end\
\
\009local package = provider(self.context, self.root)\
\009package:configure(details)\
\009local name = type .. \"-\" .. package:getName()\
\009package.installDir = fs.combine(self.root, name)\
\
\009self.packages[name] = package\
\009self.packageLookup[package] = name\
\
\009package:setup(self.context)\
\009if self.context.logger.hasError then\
\009\009error(\"Error setting up \" .. name, 2)\
\009end\
\
\009return Proxy(self, name, package)\
end\
\
function Manager:getCache(name)\
\009if not self.packages[name] then\
\009\009error(\"No such package \" .. name, 2)\
\009end\
\
\009local cache = self.cache[name]\
\009local path = fs.combine(self.root, name .. \".lua\")\
\009if cache == nil and fs.exists(path) then\
\009\009cache = dump.unserialise(fs.read(path))\
\009end\
\
\009if cache == emptyCache then cache = nil end\
\
\009return cache\
end\
\
function Manager:require(package, files, force)\
\009local name = self.packageLookup[package]\
\009if not name then error(\"No such package \" .. package:getName(), 2) end\
\
\009force = force or self.alwaysRefresh\
\
\009local cache = self:getCache(name)\
\
\009if cache and files and not force then\
\009\009local existing = package:files(cache)\
\009\009for _, file in ipairs(files) do\
\009\009\009if not existing[file] then\
\009\009\009\009force = true\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009end\
\
\009local newData = package:require(cache, force)\
\
\009-- TODO: Decent equality checking\
\009if newData ~= cache then\
\009\009self.context.logger:verbose(\"Package \" .. name .. \" updated\")\
\009\009if newData == nil then\
\009\009\009self.cache[name] = emptyCache\
\009\009else\
\009\009\009self.cache[name] = newData\
\009\009\009fs.write(fs.combine(self.root, name .. \".lua\"), dump.serialise(newData))\
\009\009end\
\009end\
\
\009local newFiles = package:files(newData)\
\009if files then\
\009\009for _, file in ipairs(files) do\
\009\009\009if not newFiles[file] then\
\009\009\009\009error(\"Cannot resolve \" .. file .. \" for \" .. name)\
\009\009\009end\
\009\009end\
\009end\
\
\009return newFiles\
end\
\
return Manager\
end\
preload[\"howl.modules.tasks.require\"] = function(...)\
--- A task that combines files that can be loaded using `require`.\
-- @module howl.modules.tasks.require\
\
local assert = require \"howl.lib.assert\"\
local fs = require \"howl.platform\".fs\
local mixin = require \"howl.class.mixin\"\
\
local Buffer = require \"howl.lib.Buffer\"\
local CopySource = require \"howl.files.CopySource\"\
local Runner = require \"howl.tasks.Runner\"\
local Task = require \"howl.tasks.Task\"\
\
local header = require \"howl.modules.tasks.require.header\"\
local envSetup = \"local env = setmetatable({ require = require, preload = preload, }, { __index = getfenv() })\\n\"\
\
local function toModule(file)\
\009if file:find(\"%.lua$\") then\
\009\009return file:gsub(\"%.lua$\", \"\"):gsub(\"/\", \".\"):gsub(\"^(.*)%.init$\", \"%1\")\
\009end\
end\
\
local function handleRes(file)\
\009if file.relative:find(\"%.res%.\") then\
\009\009file.name = file.name:gsub(\"%.res%.\", \".\")\
\009\009return (\"return %q\"):format(file.contents)\
\009end\
end\
\
local RequireTask = Task:subclass(\"howl.modules.require.RequireTask\")\
\009:include(mixin.filterable)\
\009:include(mixin.delegate(\"sources\", {\"from\", \"include\", \"exclude\"}))\
\009:addOptions { \"link\", \"startup\", \"output\", \"api\" }\
\
function RequireTask:initialize(context, name, dependencies)\
\009Task.initialize(self, name, dependencies)\
\
\009self.sources = CopySource()\
\009self.sources:rename(function(file) return toModule(file.name) end)\
\009self.sources:modify(handleRes)\
\
\009self:exclude { \".git\", \".svn\", \".gitignore\", context.out }\
\
\009self:description(\"Packages files together to allow require\")\
end\
\
function RequireTask:configure(item)\
\009Task.configure(self, item)\
\009self.sources:configure(item)\
end\
\
function RequireTask:output(value)\
\009assert.argType(value, \"string\", \"output\", 1)\
\009if self.options.output then error(\"Cannot set output multiple times\") end\
\
\009self.options.output = value\
\009self:Produces(value)\
end\
\
function RequireTask:setup(context, runner)\
\009Task.setup(self, context, runner)\
\009if not self.options.startup then\
\009\009context.logger:error(\"Task '%s': No startup file\", self.name)\
\009end\
\009self:requires(self.options.startup)\
\
\009if not self.options.output then\
\009\009context.logger:error(\"Task '%s': No output file\", self.name)\
 \009end\
end\
\
function RequireTask:runAction(context)\
\009local files = self.sources:gatherFiles(context.root)\
\009local startup = fs.combine(context.root, self.options.startup)\
\009local startup_name = nil\
\009local output = self.options.output\
\009local link = self.options.link\
\
\009local result = Buffer()\
\009result:append(header):append(\"\\n\")\
\
\009if link then result:append(envSetup) end\
\
\009for _, file in pairs(files) do\
\009\009context.logger:verbose(\"Including \" .. file.relative)\
\009\009result:append(\"preload[\\\"\" .. file.name .. \"\\\"] = \")\
\009\009if link then\
\009\009\009assert(fs.exists(file.path), \"Cannot find \" .. file.relative)\
\009\009\009result:append(\"setfenv(assert(loadfile(\\\"\" .. file.path .. \"\\\")), env)\\n\")\
\009\009else\
\009\009\009result:append(\"function(...)\\n\" .. file.contents .. \"\\nend\\n\")\
\009\009end\
\
\009\009if file.path == startup then\
\009\009\009startup_name = file.name\
\009\009end\
\009end\
\
\009if not startup_name then\
\009\009error(\"Cannot find startup file \" .. self.options.startup .. \" in file list\", 0)\
\009end\
\
\009if self.options.api then\
\009\009result:append(\"if not shell or type(... or nil) == 'table' then\\n\")\
\009\009result:append(\"local tbl = ... or {}\\n\")\
\009\009result:append(\"tbl.require = require tbl.preload = preload\\n\")\
\009\009result:append(\"return tbl\\n\")\
\009\009result:append(\"else\\n\")\
\009end\
\009result:append(\"return preload[\\\"\" .. startup_name .. \"\\\"](...)\\n\")\
\009if self.options.api then\
\009\009result:append(\"end\\n\")\
\009end\
\
\009fs.write(fs.combine(context.root, output), result:toString())\
end\
\
local RequireExtensions = { }\
\
function RequireExtensions:require(name, taskDepends)\
\009return self:injectTask(RequireTask(self.env, name, taskDepends))\
end\
\
local function apply()\
\009Runner:include(RequireExtensions)\
end\
\
return {\
\009name = \"require task\",\
\009description = \"A task that combines files that can be loaded using `require`.\",\
\009apply = apply,\
\
\009RequireTask = RequireTask,\
}\
end\
preload[\"howl.modules.tasks.require.header\"] = function(...)\
return \"local loading = {}\\\
local oldRequire, preload, loaded = require, {}, { startup = loading }\\\
\\\
local function require(name)\\\
\\009local result = loaded[name]\\\
\\\
\\009if result ~= nil then\\\
\\009\\009if result == loading then\\\
\\009\\009\\009error(\\\"loop or previous error loading module '\\\" .. name .. \\\"'\\\", 2)\\\
\\009\\009end\\\
\\\
\\009\\009return result\\\
\\009end\\\
\\\
\\009loaded[name] = loading\\\
\\009local contents = preload[name]\\\
\\009if contents then\\\
\\009\\009result = contents(name)\\\
\\009elseif oldRequire then\\\
\\009\\009result = oldRequire(name)\\\
\\009else\\\
\\009\\009error(\\\"cannot load '\\\" .. name .. \\\"'\\\", 2)\\\
\\009end\\\
\\\
\\009if result == nil then result = true end\\\
\\009loaded[name] = result\\\
\\009return result\\\
end\"\
end\
preload[\"howl.modules.tasks.pack.vfs\"] = function(...)\
return \"local fs = fs\\\
\\\
local matches = {\\\
\\009[\\\"^\\\"] = \\\"%^\\\",\\\
\\009[\\\"$\\\"] = \\\"%$\\\",\\\
\\009[\\\"(\\\"] = \\\"%(\\\",\\\
\\009[\\\")\\\"] = \\\"%)\\\",\\\
\\009[\\\"%\\\"] = \\\"%%\\\",\\\
\\009[\\\".\\\"] = \\\"%.\\\",\\\
\\009[\\\"[\\\"] = \\\"%[\\\",\\\
\\009[\\\"]\\\"] = \\\"%]\\\",\\\
\\009[\\\"*\\\"] = \\\"%*\\\",\\\
\\009[\\\"+\\\"] = \\\"%+\\\",\\\
\\009[\\\"-\\\"] = \\\"%-\\\",\\\
\\009[\\\"?\\\"] = \\\"%?\\\",\\\
\\009[\\\"\\\\0\\\"] = \\\"%z\\\",\\\
}\\\
\\\
--- Escape a string for using in a pattern\\\
-- @tparam string pattern The string to escape\\\
-- @treturn string The escaped pattern\\\
local function escapePattern(pattern)\\\
\\009return (pattern:gsub(\\\".\\\", matches))\\\
end\\\
\\\
local function matchesLocal(root, path)\\\
\\009return root == \\\"\\\" or path == root or path:sub(1, #root + 1) == root .. \\\"/\\\"\\\
end\\\
\\\
local function extractLocal(root, path)\\\
\\009if root == \\\"\\\" then\\\
\\009\\009return path\\\
\\009else\\\
\\009\\009return path:sub(#root + 2)\\\
\\009end\\\
end\\\
\\\
\\\
local function copy(old)\\\
\\009local new = {}\\\
\\009for k, v in pairs(old) do new[k] = v end\\\
\\009return new\\\
end\\\
\\\
--[[\\\
\\009Emulates a basic file system.\\\
\\009This doesn't have to be too advanced as it is only for Howl's use\\\
\\009The files is a list of paths to file contents, or true if the file\\\
\\009is a directory.\\\
\\009TODO: Override IO\\\
]]\\\
local function makeEnv(root, files)\\\
\\009-- Emulated filesystem (partially based of Oeed's)\\\
\\009files = copy(files)\\\
\\009local env\\\
\\009env = {\\\
\\009\\009fs = {\\\
\\009\\009\\009list = function(path)\\\
\\009\\009\\009\\009path = fs.combine(path, \\\"\\\")\\\
\\009\\009\\009\\009local list = fs.isDir(path) and fs.list(path) or {}\\\
\\\
\\009\\009\\009\\009if matchesLocal(root, path) then\\\
\\009\\009\\009\\009\\009local pattern = \\\"^\\\" .. escapePattern(extractLocal(root, path))\\\
\\009\\009\\009\\009\\009if pattern ~= \\\"^\\\" then pattern = pattern .. '/' end\\\
\\009\\009\\009\\009\\009pattern = pattern .. '([^/]+)$'\\\
\\\
\\009\\009\\009\\009\\009for file, _ in pairs(files) do\\\
\\009\\009\\009\\009\\009\\009local name = file:match(pattern)\\\
\\009\\009\\009\\009\\009\\009if name then list[#list + 1] = name end\\\
\\009\\009\\009\\009\\009end\\\
\\009\\009\\009\\009end\\\
\\\
\\009\\009\\009\\009return list\\\
\\009\\009\\009end,\\\
\\\
\\009\\009\\009exists = function(path)\\\
\\009\\009\\009\\009path = fs.combine(path, \\\"\\\")\\\
\\009\\009\\009\\009if fs.exists(path) then\\\
\\009\\009\\009\\009\\009return true\\\
\\009\\009\\009\\009elseif matchesLocal(root, path) then\\\
\\009\\009\\009\\009\\009return files[extractLocal(root, path)] ~= nil\\\
\\009\\009\\009\\009end\\\
\\009\\009\\009end,\\\
\\\
\\009\\009\\009isDir = function(path)\\\
\\009\\009\\009\\009path = fs.combine(path, \\\"\\\")\\\
\\009\\009\\009\\009if fs.isDir(path) then\\\
\\009\\009\\009\\009\\009return true\\\
\\009\\009\\009\\009elseif matchesLocal(root, path) then\\\
\\009\\009\\009\\009\\009return files[extractLocal(root, path)] == true\\\
\\009\\009\\009\\009end\\\
\\009\\009\\009end,\\\
\\\
\\009\\009\\009isReadOnly = function(path)\\\
\\009\\009\\009\\009path = fs.combine(path, \\\"\\\")\\\
\\009\\009\\009\\009if fs.exists(path) then\\\
\\009\\009\\009\\009\\009return fs.isReadOnly(path)\\\
\\009\\009\\009\\009elseif matchesLocal(root, path) and files[extractLocal(root, path)] ~= nil then\\\
\\009\\009\\009\\009\\009return true\\\
\\009\\009\\009\\009else\\\
\\009\\009\\009\\009\\009return false\\\
\\009\\009\\009\\009end\\\
\\009\\009\\009end,\\\
\\\
\\009\\009\\009getName = fs.getName,\\\
\\009\\009\\009getDir = fs.getDir,\\\
\\009\\009\\009getSize = fs.getSize,\\\
\\009\\009\\009getFreeSpace = fs.getFreeSpace,\\\
\\009\\009\\009combine = fs.combine,\\\
\\\
\\009\\009\\009-- TODO: This should be implemented\\\
\\009\\009\\009move = fs.move,\\\
\\009\\009\\009copy = fs.copy,\\\
\\009\\009\\009makeDir = function(dir)\\\
\\\
\\009\\009\\009end,\\\
\\009\\009\\009delete = fs.delete,\\\
\\\
\\009\\009\\009open = function(path, mode)\\\
\\009\\009\\009\\009path = fs.combine(path, \\\"\\\")\\\
\\009\\009\\009\\009if matchesLocal(root, path) then\\\
\\009\\009\\009\\009\\009local localPath = extractLocal(root, path)\\\
\\009\\009\\009\\009\\009if type(files[localPath]) == 'string' then\\\
\\009\\009\\009\\009\\009\\009local handle = {close = function()end}\\\
\\009\\009\\009\\009\\009\\009if mode == 'r' then\\\
\\009\\009\\009\\009\\009\\009\\009local content = files[localPath]\\\
\\009\\009\\009\\009\\009\\009\\009handle.readAll = function()\\\
\\009\\009\\009\\009\\009\\009\\009\\009return content\\\
\\009\\009\\009\\009\\009\\009\\009end\\\
\\\
\\009\\009\\009\\009\\009\\009\\009local line = 1\\\
\\009\\009\\009\\009\\009\\009\\009local lines\\\
\\009\\009\\009\\009\\009\\009\\009handle.readLine = function()\\\
\\009\\009\\009\\009\\009\\009\\009\\009if not lines then -- Lazy load lines\\\
\\009\\009\\009\\009\\009\\009\\009\\009\\009lines = {content:match((content:gsub(\\\"[^\\\\n]+\\\\n?\\\", \\\"([^\\\\n]+)\\\\n?\\\")))}\\\
\\009\\009\\009\\009\\009\\009\\009\\009end\\\
\\009\\009\\009\\009\\009\\009\\009\\009if line > #lines then\\\
\\009\\009\\009\\009\\009\\009\\009\\009\\009return nil\\\
\\009\\009\\009\\009\\009\\009\\009\\009else\\\
\\009\\009\\009\\009\\009\\009\\009\\009\\009return lines[line]\\\
\\009\\009\\009\\009\\009\\009\\009\\009end\\\
\\009\\009\\009\\009\\009\\009\\009\\009line = line + 1\\\
\\009\\009\\009\\009\\009\\009\\009end\\\
\\\
\\009\\009\\009\\009\\009\\009\\009return handle\\\
\\009\\009\\009\\009\\009\\009else\\\
\\009\\009\\009\\009\\009\\009\\009error('Cannot write to read-only file.', 2)\\\
\\009\\009\\009\\009\\009\\009end\\\
\\009\\009\\009\\009\\009end\\\
\\009\\009\\009\\009end\\\
\\\
\\009\\009\\009\\009return fs.open(path, mode)\\\
\\009\\009\\009end\\\
\\009\\009},\\\
\\\
\\009\\009loadfile = function(name)\\\
\\009\\009\\009local file = env.fs.open(name, \\\"r\\\")\\\
\\009\\009\\009if file then\\\
\\009\\009\\009\\009local func, err = load(file.readAll(), fs.getName(name), nil, env)\\\
\\009\\009\\009\\009file.close()\\\
\\009\\009\\009\\009return func, err\\\
\\009\\009\\009end\\\
\\009\\009\\009return nil, \\\"File not found: \\\"..name\\\
\\009\\009end,\\\
\\\
\\009\\009dofile = function(name)\\\
\\009\\009\\009local file, e = env.loadfile(name, env)\\\
\\009\\009\\009if file then\\\
\\009\\009\\009\\009return file()\\\
\\009\\009\\009else\\\
\\009\\009\\009\\009error(e, 2)\\\
\\009\\009\\009end\\\
\\009\\009end,\\\
\\009}\\\
\\\
\\009env._G = env\\\
\\009env._ENV = env\\\
\\009return setmetatable(env, {__index = _ENV or getfenv()})\\\
end\\\
\\\
local function extract(root, files, from, to)\\\
\\009local pattern = \\\"^\\\" .. escapePattern(extractLocal(root, from))\\\
\\009if pattern ~= \\\"^\\\" then pattern = pattern .. '/' end\\\
\\009pattern = pattern .. '(.*)$'\\\
\\\
\\009for file, contents in pairs(files) do\\\
\\009\\009local name = file:match(pattern)\\\
\\009\\009if name then\\\
\\009\\009\\009print(\\\"Extracting \\\" .. name)\\\
\\009\\009\\009local handle = fs.open(fs.combine(to, name), \\\"w\\\")\\\
\\009\\009\\009handle.write(contents)\\\
\\009\\009\\009handle.close()\\\
\\009\\009end\\\
\\009end\\\
end\"\
end\
preload[\"howl.modules.tasks.pack.template\"] = function(...)\
return \"local files = ${files}\\\
\\\
${vfs}\\\
\\\
local root = \\\"\\\"\\\
local args = {...}\\\
if #args == 1 and args[1] == '--extract' then\\\
\\009extract(root, files, \\\"\\\", root)\\\
else\\\
\\009local env = makeEnv(root, files)\\\
\\009local func, err = env.loadfile(${startup})\\\
\\009if not func then error(err, 0) end\\\
\\009return func(...)\\\
end\"\
end\
preload[\"howl.modules.tasks.pack\"] = function(...)\
--- A task to combine multiple files into one which are then executed within a virtual file system.\
-- @module howl.modules.tasks.Pack\
\
local assert = require \"howl.lib.assert\"\
local dump = require \"howl.lib.dump\"\
local fs = require \"howl.platform\".fs\
local mixin = require \"howl.class.mixin\"\
local rebuild = require \"howl.lexer.rebuild\"\
\
local CopySource = require \"howl.files.CopySource\"\
local Runner = require \"howl.tasks.Runner\"\
local Task = require \"howl.tasks.Task\"\
\
local formatTemplate = require \"howl.lib.utils\".formatTemplate\
\
local template = require \"howl.modules.tasks.pack.template\"\
local vfs = require \"howl.modules.tasks.pack.vfs\"\
\
local PackTask = Task:subclass(\"howl.modules.tasks.pack.PackTask\")\
\009:include(mixin.filterable)\
\009:include(mixin.delegate(\"sources\", {\"from\", \"include\", \"exclude\"}))\
\009:addOptions { \"minify\", \"startup\", \"output\" }\
\
function PackTask:initialize(context, name, dependencies)\
\009Task.initialize(self, name, dependencies)\
\
\009self.root = context.root\
\009self.sources = CopySource()\
\009self.sources:modify(function(file)\
\009\009local contents = file.contents\
\009\009if self.options.minify and loadstring(contents) then\
\009\009\009return rebuild.minifyString(contents)\
\009\009end\
\009end)\
\
\009self:exclude { \".git\", \".svn\", \".gitignore\", context.out }\
\
\009self:description(\"Combines multiple files using Pack\")\
end\
\
function PackTask:configure(item)\
\009Task.configure(self, item)\
\009self.sources:configure(item)\
end\
\
-- TODO: Add a custom \"ouput\" mixin\
function PackTask:output(value)\
\009assert.argType(value, \"string\", \"output\", 1)\
\009if self.options.output then error(\"Cannot set output multiple times\") end\
\
\009self.options.output = value\
\009self:Produces(value)\
end\
\
function PackTask:setup(context, runner)\
\009Task.setup(self, context, runner)\
\
\009if not self.options.startup then\
\009\009context.logger:error(\"Task '%s': No startup file\", self.name)\
\009end\
\009self:requires(self.options.startup)\
\
\009if not self.options.output then\
\009\009context.logger:error(\"Task '%s': No output file\", self.name)\
 \009end\
end\
\
function PackTask:runAction(context)\
\009local files = self.sources:gatherFiles(self.root)\
\009local startup = self.options.startup\
\009local output = self.options.output\
\009local minify = self.options.minify\
\
\009local resultFiles = {}\
\009for _, file in pairs(files) do\
\009\009context.logger:verbose(\"Including \" .. file.relative)\
\009\009resultFiles[file.name] = file.contents\
\009end\
\
\009local result = formatTemplate(template, {\
\009\009files = dump.serialise(resultFiles),\
\009\009startup = (\"%q\"):format(startup),\
\009\009vfs = vfs,\
\009})\
\
\009if minify then\
\009\009result = rebuild.minifyString(result)\
\009end\
\
\009fs.write(fs.combine(context.root, output), result)\
end\
\
\
local PackExtensions = { }\
\
function PackExtensions:pack(name, taskDepends)\
\009return self:injectTask(PackTask(self.env, name, taskDepends))\
end\
\
local function apply()\
\009Runner:include(PackExtensions)\
end\
\
return {\
\009name = \"pack task\",\
\009description = \"A task to combine multiple files into one which are then executed within a virtual file system.\",\
\009apply = apply,\
\
\009PackTask = PackTask,\
}\
end\
preload[\"howl.modules.tasks.minify\"] = function(...)\
--- Adds various tasks to minify files.\
-- @module howl.modules.tasks.minify\
\
local assert = require \"howl.lib.assert\"\
local rebuild = require \"howl.lexer.rebuild\"\
\
\
local Runner = require \"howl.tasks.Runner\"\
local Task = require \"howl.tasks.Task\"\
\
local minifyFile = rebuild.minifyFile\
local minifyDiscard = function(self, env, i, o)\
\009return minifyFile(env.root, i, o)\
end\
\
local MinifyTask = Task:subclass(\"howl.modules.minify.tasks.MinifyTask\")\
\009:addOptions { \"input\", \"output\" }\
\
function MinifyTask:initialize(context, name, dependencies)\
\009Task.initialize(self, name, dependencies)\
\
\009self:description \"Minify a file\"\
end\
\
function MinifyTask:input(value)\
\009assert.argType(value, \"string\", \"input\", 1)\
\009if self.options.input then error(\"Cannot set input multiple times\") end\
\
\009self.options.input = value\
\009self:requires(value)\
end\
\
function MinifyTask:output(value)\
\009assert.argType(value, \"string\", \"output\", 1)\
\009if self.options.output then error(\"Cannot set output multiple times\") end\
\
\009self.options.output = value\
\009self:Produces(value)\
end\
\
function MinifyTask:setup(context, runner)\
\009Task.setup(self, context, runner)\
\
\009if not self.options.input then\
\009\009context.logger:error(\"Task '%s': No input file specified\", self.name)\
\009end\
\
\009if not self.options.output then\
\009\009context.logger:error(\"Task '%s': No output file specified\", self.name)\
\009end\
end\
\
function MinifyTask:runAction(context)\
\009local oldSize, newSize = minifyFile(context.root, self.options.input, self.options.output)\
\009local percentDecreased = (oldSize - newSize) / oldSize * 100\
\
\009-- Ugly hack as length specifiers don't work on %f under LuaJ.\
\009percentDecreased = math.floor(percentDecreased * 100) / 100\
\009context.logger:verbose((\"%.20f%% decrease in file size\"):format(percentDecreased))\
end\
\
local MinifyExtensions = {}\
\
function MinifyExtensions:minify(name, taskDepends)\
\009return self:injectTask(MinifyTask(self.env, name, taskDepends))\
end\
\
--- A task that minifies to a pattern instead\
-- @tparam string name Name of the task\
-- @tparam string inputPattern The pattern to read in\
-- @tparam string outputPattern The pattern to produce\
-- @treturn howl.tasks.Task The created task\
function MinifyExtensions:addMinifier(name, inputPattern, outputPattern)\
\009name = name or \"_minify\"\
\009return self:addTask(name, {}, minifyDiscard)\
\009\009:Description(\"Minifies files\")\
\009\009:Maps(inputPattern or \"wild:*.lua\", outputPattern or \"wild:*.min.lua\")\
end\
\
local function apply()\
\009Runner:include(MinifyExtensions)\
end\
\
local function setup(context)\
\009context.mediator:subscribe({ \"HowlFile\", \"env\" }, function(env)\
\009\009env.minify = minifyFile\
\009end)\
end\
\
return {\
\009name = \"minify task\",\
\009description = \"Adds various tasks to minify files.\",\
\009apply = apply,\
\009setup = setup,\
}\
end\
preload[\"howl.modules.tasks.gist\"] = function(...)\
--- A task that uploads files to a Gist.\
-- @module howl.modules.tasks.gist\
\
local assert = require \"howl.lib.assert\"\
local mixin = require \"howl.class.mixin\"\
local settings = require \"howl.lib.settings\"\
local json = require \"howl.lib.json\"\
local platform = require \"howl.platform\"\
\
local http = platform.http\
\
local Buffer = require \"howl.lib.Buffer\"\
local Task = require \"howl.tasks.Task\"\
local Runner = require \"howl.tasks.Runner\"\
local CopySource = require \"howl.files.CopySource\"\
\
local GistTask = Task:subclass(\"howl.modules.tasks.gist.GistTask\")\
\009:include(mixin.filterable)\
\009:include(mixin.delegate(\"sources\", {\"from\", \"include\", \"exclude\"}))\
\009:addOptions { \"gist\", \"summary\" }\
\
function GistTask:initialize(context, name, dependencies)\
\009Task.initialize(self, name, dependencies)\
\
\009self.root = context.root\
\009self.sources = CopySource()\
\009self:exclude { \".git\", \".svn\", \".gitignore\" }\
\
\009self:description \"Uploads files to a gist\"\
end\
\
function GistTask:configure(item)\
\009Task.configure(self, context, runner)\
\009self.sources:configure(item)\
end\
\
function GistTask:setup(context, runner)\
\009Task.setup(self, context, runner)\
\009if not self.options.gist then\
\009\009context.logger:error(\"Task '%s': No gist ID specified\", self.name)\
\009end\
\009if not settings.githubKey then\
\009\009context.logger:error(\"Task '%s': No GitHub API key specified. Goto https://github.com/settings/tokens/new to create one.\", self.name)\
\009end\
end\
\
function GistTask:runAction(context)\
\009local files = self.sources:gatherFiles(self.root)\
\009local gist = self.options.gist\
\009local token = settings.githubKey\
\
\009local out = {}\
\
\009for _, file in pairs(files) do\
\009\009context.logger:verbose(\"Including \" .. file.relative)\
\009\009out[file.name] = { content = file.contents }\
\009end\
\
\009local url = \"https://api.github.com/gists/\" .. gist .. \"?access_token=\" .. token\
\009local headers = { Accept = \"application/vnd.github.v3+json\", [\"X-HTTP-Method-Override\"] = \"PATCH\" }\
\009local data = json.encodePretty({ files = out, description = self.options.summary })\
\
\009local ok, handle, message = http.request(url, data, headers)\
\009if not ok then\
\009\009if handle then\
\009\009\009context.logger:error(handle.readAll())\
\009\009end\
\
\009\009error(result, 0)\
\009end\
end\
\
local GistExtensions = { }\
\
function GistExtensions:gist(name, taskDepends)\
\009return self:injectTask(GistTask(self.env, name, taskDepends))\
end\
\
local function apply()\
\009Runner:include(GistExtensions)\
end\
\
return {\
\009name = \"gist task\",\
\009description = \"A task that uploads files to a Gist.\",\
\009apply = apply,\
\
\009GistTask = GistTask,\
}\
end\
preload[\"howl.modules.tasks.clean\"] = function(...)\
--- A task that deletes all specified files\
-- @module howl.modules.tasks.clean\
\
local mixin = require \"howl.class.mixin\"\
local fs = require \"howl.platform\".fs\
\
local Task = require \"howl.tasks.Task\"\
local Runner = require \"howl.tasks.Runner\"\
local Source = require \"howl.files.Source\"\
\
local CleanTask = Task:subclass(\"howl.modules.tasks.clean.CleanTask\")\
\009:include(mixin.configurable)\
\009:include(mixin.filterable)\
\009:include(mixin.delegate(\"sources\", {\"from\", \"include\", \"exclude\"}))\
\
function CleanTask:initialize(context, name, dependencies)\
\009Task.initialize(self, name, dependencies)\
\
\009self.root = context.root\
\009self.sources = Source()\
\009self:exclude { \".git\", \".svn\", \".gitignore\" }\
\
\009self:description \"Deletes all files matching a pattern\"\
end\
\
function CleanTask:configure(item)\
\009self.sources:configure(item)\
end\
\
function CleanTask:setup(context, runner)\
\009Task.setup(self, context, runner)\
\
\009local root = self.sources\
\009if root.allowEmpty and #root.includes == 0 then\
\009\009-- Include the build directory if nothing is set\
\009\009root:include(fs.combine(context.out, \"*\"))\
\009end\
end\
\
function CleanTask:runAction(context)\
\009for _, file in ipairs(self.sources:gatherFiles(self.root, true)) do\
\009\009context.logger:verbose(\"Deleting \" .. file.path)\
\009\009fs.delete(file.path)\
\009end\
end\
\
local CleanExtensions = {}\
\
function CleanExtensions:clean(name, taskDepends)\
\009return self:injectTask(CleanTask(self.env, name or \"clean\", taskDepends))\
end\
\
local function apply()\
\009Runner:include(CleanExtensions)\
end\
\
return {\
\009name = \"clean task\",\
\009description = \"A task that deletes all specified files.\",\
\009apply = apply,\
\
\009CleanTask = CleanTask,\
}\
end\
preload[\"howl.modules.plugins\"] = function(...)\
--- A way of injecting plugins via the Howl DSL\
-- @module howl.modules.plugins\
\
local class = require \"howl.class\"\
local mixin = require \"howl.class.mixin\"\
\
local fs = require \"howl.platform\".fs\
\
local Plugins = class(\"howl.modules.plugins\")\
\009:include(mixin.configurable)\
\
function Plugins:initialize(context)\
\009self.context = context\
end\
\
function Plugins:configure(data)\
\009if #data == 0 then\
\009\009self:addPlugin(data, data)\
\009else\
\009\009for i = 1, #data do\
\009\009\009self:addPlugin(data[i])\
\009\009end\
\009end\
end\
\
local function toModule(root, file)\
\009local name = file:gsub(\"%.lua$\", \"\"):gsub(\"/\", \".\"):gsub(\"^(.*)%.init$\", \"%1\")\
\009if name == \"\" or name == \"init\" then\
\009\009return root\
\009else\
\009\009return root .. \".\" .. name\
\009end\
end\
\
function Plugins:addPlugin(data)\
\009if not data.type then error(\"No plugin type specified\") end\
\
\009local type = data.type\
\009data.type = nil\
\
\009local file\
\009if data.file then\
\009\009file = data.file\
\009\009data.file = nil\
\009end\
\
\009local manager = self.context.packageManager\
\009local package = manager:addPackage(type, data)\
\009self.context.logger:verbose(\"Using plugin from package \" .. package:getName())\
\009local fetchedFiles = package:require(file and {file})\
\
\009local root = \"external.\" .. package:getName()\
\
\009local count = 0\
\009for file, loc in pairs(fetchedFiles) do\
\009\009if file:find(\"%.lua$\") then\
\009\009\009count = count + 1\
\
\009\009\009local func, msg = loadfile(fetchedFiles[file], _ENV)\
\009\009\009if func then\
\009\009\009\009local name = toModule(root, file)\
\009\009\009\009preload[name] = func\
\009\009\009\009self.context.logger:verbose(\"Including plugin file \" .. file .. \" as \" .. name)\
\009\009\009else\
\009\009\009\009self.context.logger:warning(\"Cannot load plugin file \" .. file .. \": \" .. msg)\
\009\009\009end\
\009\009end\
\009end\
\
\009if not file then\
\009\009if fetchedFiles[\"init.lua\"] then\
\009\009\009file = \"init.lua\"\
\009\009elseif count == 1 then\
\009\009\009file = next(fetchedFiles)\
\009\009elseif count == 0 then\
\009\009\009self.context.logger:error(package:getName() .. \" does not export any files\")\
\009\009\009error(\"Error adding plugin\")\
\009\009else\
\009\009\009self.context.logger:error(\"Cannot guess a file for \" .. package:getName())\
\009\009\009error(\"Error adding plugin\")\
\009\009end\
\009end\
\
\009self.context.logger:verbose(\"Using package \" .. package:getName() .. \" with \" .. file)\
\009local name = toModule(root, file)\
\009if not preload[name] then\
\009\009self.context.logger:error(\"Cannot load plugin as \" .. name .. \" could not be loaded\")\
\009\009error(\"Error adding plugin\")\
\009end\
\
\009self.context:include(require(name))\
\009return self\
end\
\
return {\
\009name = \"plugins\",\
\009description = \"Inject plugins into Howl at runtime.\",\
\
\009setup = function(context)\
\009\009context.mediator:subscribe({ \"HowlFile\", \"env\" }, function(env)\
\009\009\009env.plugins = Plugins(context)\
\009\009end)\
\009end\
}\
end\
preload[\"howl.modules.packages.pastebin\"] = function(...)\
--- A package provider that installs pastebins.\
-- @module howl.modules.packages.pastebin\
\
local class = require \"howl.class\"\
local platform = require \"howl.platform\"\
\
local Manager = require \"howl.packages.Manager\"\
local Package = require \"howl.packages.Package\"\
\
local PastebinPackage = Package:subclass(\"howl.modules.packages.pastebin.PastebinPackage\")\
\009:addOptions { \"id\" }\
\
--- Setup the dependency, checking if it cannot be resolved\
function PastebinPackage:setup(runner)\
\009if not self.options.id then\
\009\009self.context.logger:error(\"Pastebin has no ID\")\
\009end\
end\
\
function PastebinPackage:getName()\
\009return self.options.id\
end\
\
function PastebinPackage:files(previous)\
\009if previous then\
\009\009return {}\
\009else\
\009\009return { [\"init.lua\"] = platform.fs.combine(self.installDir, \"init.lua\") }\
\009end\
end\
\
function PastebinPackage:require(previous, refresh)\
\009local id = self.options.id\
\009local dir = self.installDir\
\
\009if not refresh and previous then\
\009\009return previous\
\009end\
\
\009local success, request = platform.http.request(\"http://pastebin.com/raw/\" .. id)\
\009if not success or not request then\
\009\009self.context.logger:error(\"Cannot find pastebin \" .. id)\
\009\009return previous\
\009end\
\
\009local contents = request.readAll()\
\009request.close()\
\
\009platform.fs.write(platform.fs.combine(dir, \"init.lua\"), contents)\
\
\009return { }\
end\
\
\
return {\
\009name = \"pastebin package\",\
\009description = \"Allows downloading a pastebin dependency.\",\
\
\009apply = function()\
\009\009Manager:addProvider(PastebinPackage, \"pastebin\")\
\009end,\
\
\009PastebinPackage = PastebinPackage,\
}\
end\
preload[\"howl.modules.packages.gist\"] = function(...)\
--- A package provider that installs gists.\
-- @module howl.modules.packages.gist\
\
local class = require \"howl.class\"\
local json = require \"howl.lib.json\"\
local platform = require \"howl.platform\"\
\
local Manager = require \"howl.packages.Manager\"\
local Package = require \"howl.packages.Package\"\
\
local GistPackage = Package:subclass(\"howl.modules.packages.gist.GistPackage\")\
\009:addOptions { \"id\" }\
\
--- Setup the dependency, checking if it cannot be resolved\
function GistPackage:setup(runner)\
\009if not self.options.id then\
\009\009self.context.logger:error(\"Gist has no ID\")\
\009end\
end\
\
function GistPackage:getName()\
\009return self.options.id\
end\
\
function GistPackage:files(previous)\
\009if previous then\
\009\009local files = {}\
\009\009for k, _ in pairs(previous.files) do\
\009\009\009files[k] = platform.fs.combine(self.installDir, k)\
\009\009end\
\009\009return files\
\009else\
\009\009return {}\
\009end\
end\
\
function GistPackage:require(previous, refresh)\
\009local id = self.options.id\
\009local dir = self.installDir\
\
\009if not refresh and previous then\
\009\009return previous\
\009end\
\
\009-- TODO: Fetch gists/:id/commits [1].version first if we have a hash\
\009-- TODO: Worth storing individual versions?\
\009local success, request = platform.http.request(\"https://api.github.com/gists/\" .. id)\
\009if not success or not request then\
\009\009self.context.logger:error(\"Cannot find gist \" .. id)\
\009\009return false\
\009end\
\
\009local contents = request.readAll()\
\009request.close()\
\
\009local data = json.decode(contents)\
\009local hash = data.history[1].version\
\009local current\
\
\009if previous and hash == previous.hash then\
\009\009current = previous\
\009else\
\009\009current = { hash = hash, files = {} }\
\009\009for path, file in pairs(data.files) do\
\009\009\009if file.truncated then\
\009\009\009\009self.context.logger:error(\"Skipping \" .. path .. \" as it is truncated\")\
\009\009\009else\
\009\009\009\009platform.fs.write(platform.fs.combine(dir, path), file.content)\
\009\009\009\009current.files[path] = true\
\009\009\009end\
\009\009end\
\009end\
\
\009return current\
end\
\
\
return {\
\009name = \"gist package\",\
\009description = \"Allows downloading a gist dependency.\",\
\
\009apply = function()\
\009\009Manager:addProvider(GistPackage, \"gist\")\
\009end,\
\
\009GistPackage = GistPackage,\
}\
end\
preload[\"howl.modules.packages.file\"] = function(...)\
--- A package provider that uses a local file.\
-- @module howl.modules.packages.file\
\
local class = require \"howl.class\"\
local mixin = require \"howl.class.mixin\"\
local fs = require \"howl.platform\".fs\
\
local Manager = require \"howl.packages.Manager\"\
local Package = require \"howl.packages.Package\"\
local Source = require \"howl.files.Source\"\
\
local FilePackage = Package:subclass(\"howl.modules.packages.file.FilePackage\")\
\009:include(mixin.filterable)\
\009:include(mixin.delegate(\"sources\", {\"from\", \"include\", \"exclude\"}))\
\
function FilePackage:initialize(context, root)\
\009Package.initialize(self, context, root)\
\
\009self.sources = Source(false)\
\009self.name = tostring({}):sub(8)\
\009self:exclude { \".git\", \".svn\", \".gitignore\", context.out }\
end\
\
--- Setup the dependency, checking if it cannot be resolved\
function FilePackage:setup(runner)\
\009if not self.sources:hasFiles() then\
\009\009self.context.logger:error(\"No files specified\")\
\009end\
end\
\
function FilePackage:configure(item)\
\009Package.configure(self, item)\
\009self.sources:configure(item)\
end\
\
function FilePackage:getName()\
\009return self.name\
end\
\
function FilePackage:files(previous)\
\009local files = {}\
\009for _, v in pairs(self.sources:gatherFiles(self.context.root)) do\
\009\009files[v.name] = v.path\
\009end\
\009return files\
end\
\
function FilePackage:require(previous, refresh)\
end\
\
\
return {\
\009name = \"file package\",\
\009description = \"Allows using a local file as a dependency\",\
\
\009apply = function()\
\009\009Manager:addProvider(FilePackage, \"file\")\
\009end,\
\
\009FilePackage = FilePackage,\
}\
end\
preload[\"howl.modules.list\"] = function(...)\
--- Lists all tasks on a runner.\
-- @module howl.modules.list\
\
local assert = require \"howl.lib.assert\"\
local colored = require \"howl.lib.colored\"\
\
local Runner = require \"howl.tasks.Runner\"\
\
local ListTasksExtensions = { }\
\
function ListTasksExtensions:listTasks(indent, all)\
\009local taskNames = {}\
\009local maxLength = 0\
\009for name, task in pairs(self.tasks) do\
\009\009local start = name:sub(1, 1)\
\009\009if all or (start ~= \"_\" and start ~= \".\") then\
\009\009\009local description = task.options.description or \"\"\
\009\009\009local length = #name\
\009\009\009if length > maxLength then\
\009\009\009\009maxLength = length\
\009\009\009end\
\
\009\009\009taskNames[name] = description\
\009\009end\
\009end\
\
\009maxLength = maxLength + 2\
\009indent = indent or \"\"\
\009for name, description in pairs(taskNames) do\
\009\009colored.writeColor(\"white\", indent .. name)\
\009\009colored.printColor(\"lightGray\", string.rep(\" \", maxLength - #name) .. description)\
\009end\
\
\009return self\
end\
\
local function apply()\
\009Runner:include(ListTasksExtensions)\
end\
\
return {\
\009name = \"list\",\
\009description = \"List all tasks on a runner.\",\
\009apply = apply,\
}\
end\
preload[\"howl.modules.dependencies.task\"] = function(...)\
--- Allows depending on a task.\
-- @module howl.modules.dependencies.task\
\
local assert = require \"howl.lib.assert\"\
local Task = require \"howl.tasks.Task\"\
local Dependency = require \"howl.tasks.Dependency\"\
\
local TaskDependency = Dependency:subclass(\"howl.modules.dependencies.task.TaskDependency\")\
\
--- Create a new task dependency\
function TaskDependency:initialize(task, name)\
\009Dependency.initialize(self, task)\
\
\009assert.argType(name, \"string\", \"initialize\", 1)\
\009self.name = name\
end\
\
function TaskDependency:setup(context, runner)\
\009if not runner.tasks[self.name] then\
\009\009context.logger:error(\"Task '%s': cannot resolve dependency '%s'\", self.task.name, self.name)\
\009end\
end\
\
function TaskDependency:resolve(context, runner)\
\009return runner:run(self.name)\
end\
\
return {\
\009name = \"task dependency\",\
\009description = \"Allows depending on a task.\",\
\
\009apply = function()\
\009\009Task:addDependency(TaskDependency, \"depends\")\
\009end,\
\
\009TaskDependency = TaskDependency,\
}\
end\
preload[\"howl.modules.dependencies.file\"] = function(...)\
--- Allows depending on a file.\
-- @module howl.modules.dependencies.file\
\
local assert = require \"howl.lib.assert\"\
local Task = require \"howl.tasks.Task\"\
local Dependency = require \"howl.tasks.Dependency\"\
\
local FileDependency = Dependency:subclass(\"howl.modules.dependencies.file.FileDependency\")\
\
--- Create a new task dependency\
function FileDependency:initialize(task, path)\
\009Dependency.initialize(self, task)\
\
\009assert.argType(path, \"string\", \"initialize\", 1)\
\009self.path = path\
end\
\
function FileDependency:setup(context, runner)\
\009-- TODO: Check that this can be resolved\
end\
\
function FileDependency:resolve(context, runner)\
\009return runner:DoRequire(self.path)\
end\
\
return {\
\009name = \"file dependency\",\
\009description = \"Allows depending on a file.\",\
\
\009apply = function()\
\009\009Task:addDependency(FileDependency, \"requires\")\
\009end,\
\
\009FileDependency = FileDependency,\
}\
end\
preload[\"howl.loader\"] = function(...)\
--- Handles loading and creation of HowlFiles\
-- @module howl.loader\
\
local fs = require \"howl.platform\".fs\
local Runner = require \"howl.tasks.Runner\"\
local Utils = require \"howl.lib.utils\"\
\
--- Names to test when searching for Howlfiles\
local Names = { \"Howlfile\", \"Howlfile.lua\" }\
\
--- Finds the howl file\
-- @treturn string The name of the howl file or nil if not found\
-- @treturn string The path of the howl file or the error message if not found\
local function FindHowl()\
\009local currentDirectory = fs.currentDir()\
\
\009while true do\
\009\009for _, file in ipairs(Names) do\
\009\009\009local howlFile = fs.combine(currentDirectory, file)\
\009\009\009if fs.exists(howlFile) and not fs.isDir(howlFile) then\
\009\009\009\009return file, currentDirectory\
\009\009\009end\
\009\009end\
\
\009\009if currentDirectory == \"/\" or currentDirectory == \"\" then\
\009\009\009break\
\009\009end\
\009\009currentDirectory = fs.getDir(currentDirectory)\
\009end\
\
\
\009return nil, \"Cannot find HowlFile. Looking for '\" .. table.concat(Names, \"', '\") .. \"'.\"\
end\
\
--- Create an environment for running howl files\
-- @tparam table variables A list of variables to include in the environment\
-- @treturn table The created environment\
local function SetupEnvironment(variables)\
\009local env = setmetatable(variables or {}, { __index = _ENV })\
\
\009function env.loadfile(path)\
\009\009return assert(loadfile(path, env))\
\009end\
\
\009function env.dofile(path)\
\009\009return env.loadfile(path)()\
\009end\
\
\009return env\
end\
\
--- Setup tasks\
-- @tparam howl.Context context The current environment\
-- @tparam string howlFile location of Howlfile relative to current directory\
-- @treturn Runner The task runner\
local function SetupTasks(context, howlFile)\
\009local tasks = Runner(context)\
\
\009context.mediator:subscribe({ \"ArgParse\", \"changed\" }, function(options)\
\009\009tasks.ShowTime = options:Get \"time\"\
\009\009tasks.Traceback = options:Get \"trace\"\
\009end)\
\
\009-- Setup an environment\
\009local environment = SetupEnvironment({\
\009\009-- Core globals\
\009\009require = require,\
\009\009CurrentDirectory = context.root,\
\009\009Tasks = tasks,\
\009\009Options = context.arguments,\
\009\009-- Helper functions\
\009\009Verbose = context.logger/\"verbose\",\
\009\009Log = context.logger/\"dump\",\
\009\009File = function(...) return fs.combine(context.root, ...) end,\
\009})\
\
\009context.mediator:publish({ \"HowlFile\", \"env\" }, environment, context)\
\
\009return tasks, environment\
end\
\
\
--- @export\
return {\
\009FindHowl = FindHowl,\
\009SetupEnvironment = SetupEnvironment,\
\009SetupTasks = SetupTasks,\
\009Names = Names,\
}\
end\
preload[\"howl.lib.utils\"] = function(...)\
--- Useful little helpers for things\
-- @module howl.lib.utils\
\
local assert = require \"howl.lib.assert\"\
\
local matches = {\
\009[\"^\"] = \"%^\",\
\009[\"$\"] = \"%$\",\
\009[\"(\"] = \"%(\",\
\009[\")\"] = \"%)\",\
\009[\"%\"] = \"%%\",\
\009[\".\"] = \"%.\",\
\009[\"[\"] = \"%[\",\
\009[\"]\"] = \"%]\",\
\009[\"*\"] = \"%*\",\
\009[\"+\"] = \"%+\",\
\009[\"-\"] = \"%-\",\
\009[\"?\"] = \"%?\",\
\009[\"\\0\"] = \"%z\",\
}\
\
--- Escape a string for using in a pattern\
-- @tparam string pattern The string to escape\
-- @treturn string The escaped pattern\
local function escapePattern(pattern)\
\009return (pattern:gsub(\".\", matches))\
end\
\
local basicMatches = {\
\009[\"^\"] = \"%^\",\
\009[\"$\"] = \"%$\",\
\009[\"(\"] = \"%(\",\
\009[\")\"] = \"%)\",\
\009[\"%\"] = \"%%\",\
\009[\".\"] = \"%.\",\
\009[\"[\"] = \"%[\",\
\009[\"]\"] = \"%]\",\
\009[\"+\"] = \"%+\",\
\009[\"-\"] = \"%-\",\
\009[\"?\"] = \"%?\",\
\009[\"\\0\"] = \"%z\",\
}\
\
--- A resulting pattern\
-- @table Pattern\
-- @tfield string Type `Pattern` or `Normal`\
-- @tfield string Text The resulting pattern\
\
--- Parse a series of patterns\
-- @tparam string text Pattern to parse\
-- @tparam boolean invert If using a wildcard, invert it\
-- @treturn Pattern\
local function parsePattern(text, invert)\
\009local beginning = text:sub(1, 5)\
\009if beginning == \"ptrn:\" or beginning == \"wild:\" then\
\
\009\009local text = text:sub(6)\
\009\009if beginning == \"wild:\" then\
\009\009\009if invert then\
\009\009\009\009local counter = 0\
\009\009\009\009-- Escape the pattern and then replace wildcards with the results of the capture %1, %2, etc...\
\009\009\009\009text = ((text:gsub(\".\", basicMatches)):gsub(\"(%*)\", function()\
\009\009\009\009\009counter = counter + 1\
\009\009\009\009\009return \"%\" .. counter\
\009\009\009\009end))\
\009\009\009else\
\009\009\009\009-- Escape the pattern and replace wildcards with (.*) capture\
\009\009\009\009text = \"^\" .. ((text:gsub(\".\", basicMatches)):gsub(\"(%*)\", \"(.*)\")) .. \"$\"\
\009\009\009end\
\009\009end\
\
\009\009return { Type = \"Pattern\", Text = text }\
\009else\
\009\009return { Type = \"Normal\", Text = text }\
\009end\
end\
\
--- Create a lookup table from a list of values\
-- @tparam table tbl The table of values\
-- @treturn The same table, with lookups as well\
local function createLookup(tbl)\
\009for _, v in ipairs(tbl) do\
\009\009tbl[v] = true\
\009end\
\009return tbl\
end\
\
--- Checks if two tables are equal\
-- @tparam table a\
-- @tparam table b\
-- @treturn boolean If they match\
local function matchTables(a, b)\
\009local length = #a\
\009if length ~= #b then return false end\
\
\009for i = 1, length do\
\009\009if a[i] ~= b[i] then return false end\
\009end\
\009return true\
end\
\
local function startsWith(string, text)\
\009if string:sub(1, #text) == text then\
\009\009return string:sub(#text + 1)\
\009else\
\009\009return false\
\009end\
end\
\
--- Format a template string with data.\
-- Anything of the form `${var}` will be replaced with the appropriate variable in the table.\
-- @tparam string template The template to format\
-- @tparam table data The data to replace with\
-- @treturn string The formatted template\
local function formatTemplate(template, data)\
\009return (template:gsub(\"${([^}]+)}\", function(str)\
\009\009local res = data[str]\
\009\009if res == nil then\
\009\009\009return \"${\" .. str .. \"}\"\
\009\009else\
\009\009\009return tostring(res)\
\009\009end\
\009end))\
end\
\
--- Mark a function as deprecated\
-- @tparam string name The name of the function\
-- @tparam function function The function to delegate to\
-- @tparam string|nil msg Additional message to print\
local function deprecated(name, func, msg)\
\009assert.argType(name, \"string\", \"deprecated\", 1)\
\009assert.argType(func, \"function\", \"deprecated\", 2)\
\
\009if msg ~= nil then\
\009\009assert.argType(msg, \"string\", \"msg\", 4)\
\009\009msg = \" \" .. msg\
\009else\
\009\009msg = \"\"\
\009end\
\
\009local doneDeprc = false\
\009return function(...)\
\009\009if not doneDeprc then\
\009\009\009local _, callee = pcall(error, \"\", 3)\
\009\009\009callee = callee:gsub(\":%s*$\", \"\")\
\009\009\009print(name .. \" is deprecated (called at \" .. callee .. \").\" .. msg)\
\009\009\009doneDeprc = true\
\009\009end\
\
\009\009return func(...)\
\009end\
end\
\
--- @export\
return {\
\009escapePattern = escapePattern,\
\009parsePattern = parsePattern,\
\009createLookup = createLookup,\
\009matchTables = matchTables,\
\009startsWith = startsWith,\
\009formatTemplate = formatTemplate,\
\009deprecated = deprecated,\
}\
end\
preload[\"howl.lib.settings\"] = function(...)\
local platform = require \"howl.platform\"\
local fs = platform.fs\
local dump = require \"howl.lib.dump\"\
\
local currentSettings = {\
}\
\
if fs.exists(\".howl.settings.lua\") then\
\009local contents = fs.read(\".howl.settings.lua\")\
\
\009for k, v in pairs(dump.unserialise(contents)) do\
\009\009currentSettings[k] = v\
\009end\
end\
\
if fs.exists(\".howl/settings.lua\") then\
\009local contents = fs.read(\".howl/settings.lua\")\
\
\009for k, v in pairs(dump.unserialise(contents)) do\
\009\009currentSettings[k] = v\
\009end\
end\
\
-- Things have to be defined in currentSettings for this to work. We need to improve this.\
for k, v in pairs(currentSettings) do\
\009currentSettings[k] = platform.os.getEnv(\"howl.\" .. k, v)\
end\
\
return currentSettings\
end\
preload[\"howl.lib.mediator\"] = function(...)\
--- Mediator pattern implementation for pub-sub management\
--\
-- [Adapted from Olivine Labs' Mediator](http://olivinelabs.com/mediator_lua/)\
-- @module howl.lib.mediator\
\
local class = require \"howl.class\"\
local mixin = require \"howl.class.mixin\"\
\
local function getUniqueId()\
\009return tonumber(tostring({}):match(':%s*[0xX]*(%x+)'), 16)\
end\
\
--- A subscriber to a channel\
-- @type Subscriber\
local Subscriber = class(\"howl.lib.mediator.Subscriber\"):include(mixin.sealed)\
\
--- Create a new subscriber\
-- @tparam function fn The function to execute\
-- @tparam table options Options to use\
-- @constructor\
function Subscriber:initialize(fn, options)\
\009self.id = getUniqueId()\
\009self.options = options or {}\
\009self.fn = fn\
end\
\
--- Update the subscriber with new options\
-- @tparam table options Options to use\
function Subscriber:update(options)\
\009self.fn = options.fn or self.fn\
\009self.options = options.options or self.options\
end\
\
\
--- Channel class and functions\
-- @type Channel\
local Channel = class(\"howl.lib.mediator.Channel\"):include(mixin.sealed)\
\
function Channel:initialize(namespace, parent)\
\009self.stopped = false\
\009self.namespace = namespace\
\009self.callbacks = {}\
\009self.channels = {}\
\009self.parent = parent\
end\
\
function Channel:addSubscriber(fn, options)\
\009local callback = Subscriber(fn, options)\
\009local priority = (#self.callbacks + 1)\
\
\009options = options or {}\
\
\009if options.priority and\
\009\009options.priority >= 0 and\
\009\009options.priority < priority\
\009then\
\009\009priority = options.priority\
\009end\
\
\009table.insert(self.callbacks, priority, callback)\
\
\009return callback\
end\
\
function Channel:getSubscriber(id)\
\009for i = 1, #self.callbacks do\
\009\009local callback = self.callbacks[i]\
\009\009if callback.id == id then return { index = i, value = callback } end\
\009end\
\009local sub\
\009for _, channel in pairs(self.channels) do\
\009\009sub = channel:getSubscriber(id)\
\009\009if sub then break end\
\009end\
\009return sub\
end\
\
function Channel:setPriority(id, priority)\
\009local callback = self:getSubscriber(id)\
\
\009if callback.value then\
\009\009table.remove(self.callbacks, callback.index)\
\009\009table.insert(self.callbacks, priority, callback.value)\
\009end\
end\
\
function Channel:addChannel(namespace)\
\009self.channels[namespace] = Channel(namespace, self)\
\009return self.channels[namespace]\
end\
\
function Channel:hasChannel(namespace)\
\009return namespace and self.channels[namespace] and true\
end\
\
function Channel:getChannel(namespace)\
\009return self.channels[namespace] or self:addChannel(namespace)\
end\
\
function Channel:removeSubscriber(id)\
\009local callback = self:getSubscriber(id)\
\
\009if callback and callback.value then\
\009\009for _, channel in pairs(self.channels) do\
\009\009\009channel:removeSubscriber(id)\
\009\009end\
\
\009\009return table.remove(self.callbacks, callback.index)\
\009end\
end\
\
function Channel:publish(result, ...)\
\009for i = 1, #self.callbacks do\
\009\009local callback = self.callbacks[i]\
\
\009\009-- if it doesn't have a predicate, or it does and it's true then run it\
\009\009if not callback.options.predicate or callback.options.predicate(...) then\
\009\009\009-- just take the first result and insert it into the result table\
\009\009\009local continue, value = callback.fn(...)\
\
\009\009\009if value ~= nil then table.insert(result, value) end\
\009\009\009if continue == false then return false, result end\
\009\009end\
\009end\
\
\009if self.parent then\
\009\009return self.parent:publish(result, ...)\
\009else\
\009\009return true, result\
\009end\
end\
\
--- Mediator class and functions\
local Mediator = setmetatable(\
\009{\
\009\009Channel = Channel,\
\009\009Subscriber = Subscriber\
\009},\
\009{\
\009\009__call = function(fn, options)\
\009\009\009return {\
\009\009\009\009channel = Channel('root'),\
\
\009\009\009\009getChannel = function(self, channelNamespace)\
\009\009\009\009\009local channel = self.channel\
\
\009\009\009\009\009for i=1, #channelNamespace do\
\009\009\009\009\009\009channel = channel:getChannel(channelNamespace[i])\
\009\009\009\009\009end\
\
\009\009\009\009\009return channel\
\009\009\009\009end,\
\
\009\009\009\009subscribe = function(self, channelNamespace, fn, options)\
\009\009\009\009\009return self:getChannel(channelNamespace):addSubscriber(fn, options)\
\009\009\009\009end,\
\
\009\009\009\009getSubscriber = function(self, id, channelNamespace)\
\009\009\009\009\009return self:getChannel(channelNamespace):getSubscriber(id)\
\009\009\009\009end,\
\
\009\009\009\009removeSubscriber = function(self, id, channelNamespace)\
\009\009\009\009\009return self:getChannel(channelNamespace):removeSubscriber(id)\
\009\009\009\009end,\
\
\009\009\009\009publish = function(self, channelNamespace, ...)\
\009\009\009\009\009return self:getChannel(channelNamespace):publish({}, ...)\
\009\009\009\009end\
\009\009\009}\
\009\009end\
\009}\
)\
return Mediator()\
end\
preload[\"howl.lib.Logger\"] = function(...)\
--- The main logger for Lua\
-- @classmod howl.lib.Logger\
\
local class = require \"howl.class\"\
local mixin = require \"howl.class.mixin\"\
local dump = require \"howl.lib.dump\".dump\
local colored = require \"howl.lib.colored\"\
local platformLog = require \"howl.platform\".log\
\
local select, tostring = select, tostring\
local function concat(...)\
\009local buffer = {}\
\009for i = 1, select('#', ...) do\
\009\009buffer[i] = tostring(select(i, ...))\
\009end\
\009return table.concat(buffer, \" \")\
end\
\
local Logger = class(\"howl.lib.Logger\")\
\009:include(mixin.sealed)\
\009:include(mixin.curry)\
\
function Logger:initialize(context)\
\009self.isVerbose = false\
\009context.mediator:subscribe({ \"ArgParse\", \"changed\" }, function(options)\
\009\009self.isVerbose = options:Get \"verbose\" or false\
\009end)\
end\
\
--- Print a series of objects if verbose mode is enabled\
function Logger:verbose(...)\
\009if self.isVerbose then\
\009\009local _, m = pcall(function() error(\"\", 4) end)\
\009\009colored.writeColor(\"gray\", m)\
\009\009colored.printColor(\"lightGray\", ...)\
\009\009platformLog(\"verbose\", m .. concat(...))\
\009end\
end\
\
--- Dump a series of objects if verbose mode is enabled\
function Logger:dump(...)\
\009if self.isVerbose then\
\009\009local _, m = pcall(function() error(\"\", 4) end)\
\009\009colored.writeColor(\"gray\", m)\
\
\009\009local len = select('#', ...)\
\009\009local args = {...}\
\009\009for i = 1, len do\
\009\009\009local value = args[i]\
\009\009\009local t = type(value)\
\009\009\009if t == \"table\" then\
\009\009\009\009value = dump(value)\
\009\009\009else\
\009\009\009\009value = tostring(value)\
\009\009\009end\
\
\009\009\009if i > 1 then value = \" \" .. value end\
\009\009\009-- TODO: use platformLog too.\
\009\009\009colored.writeColor(\"lightGray\", value)\
\009\009end\
\009\009print()\
\009end\
end\
\
local types = {\
\009{ \"success\", \"ok\", \"green\" },\
\009{ \"error\", \"error\", \"red\" },\
\009{ \"info\", \"info\", \"cyan\" },\
\009{ \"warning\", \"warn\", \"yellow\" },\
}\
\
local max = 0\
for _, v in ipairs(types) do\
\009max = math.max(max, #v[2])\
end\
\
for _, v in ipairs(types) do\
\009local color = v[3]\
\009local format = '[' .. v[2] .. ']' .. (' '):rep(max - #v[2] + 1)\
\009local field = \"has\" .. v[2]:gsub(\"^%l\", string.upper)\
\009local name = v[1]\
\
\009Logger[name] = function(self, fmt, ...)\
\009\009self[field] = true\
\009\009colored.writeColor(color, format)\
\
\009\009local text\
\009\009if type(fmt) == \"string\" then\
\009\009\009text = fmt:format(...)\
\009\009else\
\
\009\009end\
\
\009\009colored.printColor(color, text)\
\009\009platformLog(name, text)\
\009end\
end\
\
return Logger\
end\
preload[\"howl.lib.json\"] = function(...)\
local controls = {[\"\\n\"]=\"\\\\n\", [\"\\r\"]=\"\\\\r\", [\"\\t\"]=\"\\\\t\", [\"\\b\"]=\"\\\\b\", [\"\\f\"]=\"\\\\f\", [\"\\\"\"]=\"\\\\\\\"\", [\"\\\\\"]=\"\\\\\\\\\"}\
local function isArray(t)\
\009local max = 0\
\009for k,v in pairs(t) do\
\009\009if type(k) ~= \"number\" then\
\009\009\009return false\
\009\009elseif k > max then\
\009\009\009max = k\
\009\009end\
\009end\
\009return max == #t\
end\
\
\
local function encodeCommon(val, pretty, tabLevel, tTracking, ctx)\
\009local str = \"\"\
\
\009-- Tabbing util\
\009local function tab(s)\
\009\009str = str .. (\"\\t\"):rep(tabLevel) .. s\
\009end\
\
\009local function arrEncoding(val, bracket, closeBracket, iterator, loopFunc)\
\009\009str = str .. bracket\
\009\009if pretty then\
\009\009\009str = str .. \"\\n\"\
\009\009\009tabLevel = tabLevel + 1\
\009\009end\
\009\009for k,v in iterator(val) do\
\009\009\009tab(\"\")\
\009\009\009loopFunc(k,v)\
\009\009\009str = str .. \",\"\
\009\009\009if pretty then str = str .. \"\\n\" end\
\009\009end\
\009\009if pretty then\
\009\009\009tabLevel = tabLevel - 1\
\009\009end\
\009\009if str:sub(-2) == \",\\n\" then\
\009\009\009str = str:sub(1, -3) .. \"\\n\"\
\009\009elseif str:sub(-1) == \",\" then\
\009\009\009str = str:sub(1, -2)\
\009\009end\
\009\009tab(closeBracket)\
\009end\
\
\009-- Table encoding\
\009if type(val) == \"table\" then\
\009\009assert(not tTracking[val], \"Cannot encode a table holding itself recursively\")\
\009\009tTracking[val] = true\
\009\009if isArray(val) then\
\009\009\009arrEncoding(val, \"[\", \"]\", ipairs, function(k,v)\
\009\009\009\009str = str .. encodeCommon(v, pretty, tabLevel, tTracking)\
\009\009\009end)\
\009\009else\
\009\009\009arrEncoding(val, \"{\", \"}\", pairs, function(k,v)\
\009\009\009\009assert(type(k) == \"string\", \"JSON object keys must be strings\", 2)\
\009\009\009\009str = str .. encodeCommon(k, pretty, tabLevel, tTracking)\
\009\009\009\009str = str .. (pretty and \": \" or \":\") .. encodeCommon(v, pretty, tabLevel, tTracking, k)\
\009\009\009end)\
\009\009end\
\009-- String encoding\
\009elseif type(val) == \"string\" then\
\009\009str = '\"' .. val:gsub(\"[%c\\\"\\\\]\", controls) .. '\"'\
\009-- Number encoding\
\009elseif type(val) == \"number\" or type(val) == \"boolean\" then\
\009\009str = tostring(val)\
\009else\
\009\009error(\"JSON only supports arrays, objects, numbers, booleans, and strings, got \" .. type(val) .. \" in \" .. tostring(ctx), 2)\
\009end\
\009return str\
end\
\
local function encode(val)\
\009return encodeCommon(val, false, 0, {})\
end\
\
local function encodePretty(val)\
\009return encodeCommon(val, true, 0, {})\
end\
\
-- Decoding\
local whites = {['\\n']=true; ['\\r']=true; ['\\t']=true; [' ']=true; [',']=true; [':']=true}\
local function removeWhite(str)\
\009while whites[str:sub(1, 1)] do\
\009\009str = str:sub(2)\
\009end\
\009return str\
end\
\
local decodeControls = {}\
for k,v in pairs(controls) do\
\009decodeControls[v] = k\
end\
\
local function parseBoolean(str)\
\009if str:sub(1, 4) == \"true\" then\
\009\009return true, removeWhite(str:sub(5))\
\009else\
\009\009return false, removeWhite(str:sub(6))\
\009end\
end\
\
local function parseNull(str)\
\009return nil, removeWhite(str:sub(5))\
end\
\
local numChars = {['e']=true; ['E']=true; ['+']=true; ['-']=true; ['.']=true}\
local function parseNumber(str)\
\009local i = 1\
\009while numChars[str:sub(i, i)] or tonumber(str:sub(i, i)) do\
\009\009i = i + 1\
\009end\
\009local val = tonumber(str:sub(1, i - 1))\
\009str = removeWhite(str:sub(i))\
\009return val, str\
end\
\
local function parseString(str)\
\009str = str:sub(2)\
\009local s = \"\"\
\009while str:sub(1,1) ~= \"\\\"\" do\
\009\009local next = str:sub(1,1)\
\009\009str = str:sub(2)\
\009\009assert(next ~= \"\\n\", \"Unclosed string\")\
\
\009\009if next == \"\\\\\" then\
\009\009\009local escape = str:sub(1,1)\
\009\009\009str = str:sub(2)\
\
\009\009\009next = assert(decodeControls[next..escape], \"Invalid escape character\")\
\009\009end\
\
\009\009s = s .. next\
\009end\
\009return s, removeWhite(str:sub(2))\
end\
\
local parseValue\
local function parseArray(str)\
\009str = removeWhite(str:sub(2))\
\
\009local val = {}\
\009local i = 1\
\009while str:sub(1, 1) ~= \"]\" do\
\009\009local v = nil\
\009\009v, str = parseValue(str)\
\009\009val[i] = v\
\009\009i = i + 1\
\009\009str = removeWhite(str)\
\009end\
\009str = removeWhite(str:sub(2))\
\009return val, str\
end\
\
local function parseMember(str)\
\009local k = nil\
\009k, str = parseValue(str)\
\009local val = nil\
\009val, str = parseValue(str)\
\009return k, val, str\
end\
\
local function parseObject(str)\
\009str = removeWhite(str:sub(2))\
\
\009local val = {}\
\009while str:sub(1, 1) ~= \"}\" do\
\009\009local k, v = nil, nil\
\009\009k, v, str = parseMember(str)\
\009\009val[k] = v\
\009\009str = removeWhite(str)\
\009end\
\009str = removeWhite(str:sub(2))\
\009return val, str\
end\
\
function parseValue(str)\
\009local fchar = str:sub(1, 1)\
\009if fchar == \"{\" then\
\009\009return parseObject(str)\
\009elseif fchar == \"[\" then\
\009\009return parseArray(str)\
\009elseif tonumber(fchar) ~= nil or numChars[fchar] then\
\009\009return parseNumber(str)\
\009elseif str:sub(1, 4) == \"true\" or str:sub(1, 5) == \"false\" then\
\009\009return parseBoolean(str)\
\009elseif fchar == \"\\\"\" then\
\009\009return parseString(str)\
\009elseif str:sub(1, 4) == \"null\" then\
\009\009return parseNull(str)\
\009end\
\009return nil\
end\
\
local function decode(str)\
\009str = removeWhite(str)\
\009return parseValue(str)\
end\
\
return {\
\009encode = encode,\
\009encodePretty = encodePretty,\
\009decode = decode,\
}\
end\
preload[\"howl.lib.dump\"] = function(...)\
--- Allows formatting tables for logging and storing\
-- @module howl.lib.dump\
\
local Buffer = require(\"howl.lib.Buffer\")\
local createLookup = require(\"howl.lib.utils\").createLookup\
\
local type, tostring, format = type, tostring, string.format\
local getmetatable, error = getmetatable, error\
\
-- TODO: Switch to LuaCP's pprint\
local function dumpImpl(t, tracking, indent, tupleLength)\
\009local objType = type(t)\
\009if objType == \"table\" and not tracking[t] then\
\009\009tracking[t] = true\
\
\009\009if next(t) == nil then\
\009\009\009return \"{}\"\
\009\009else\
\009\009\009local shouldNewLine = false\
\009\009\009local length = #t\
\
\009\009\009local builder = 0\
\009\009\009for k,v in pairs(t) do\
\009\009\009\009if type(k) == \"table\" or type(v) == \"table\" then\
\009\009\009\009\009shouldNewLine = true\
\009\009\009\009\009break\
\009\009\009\009elseif type(k) == \"number\" and k >= 1 and k <= length and k % 1 == 0 then\
\009\009\009\009\009builder = builder + #tostring(v) + 2\
\009\009\009\009else\
\009\009\009\009\009builder = builder + #tostring(v) + #tostring(k) + 2\
\009\009\009\009end\
\
\009\009\009\009if builder > 40 then\
\009\009\009\009\009shouldNewLine = true\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009local newLine, nextNewLine, subIndent = \"\", \", \", \" \"\
\009\009\009if shouldNewLine then\
\009\009\009\009newLine = \"\\n\"\
\009\009\009\009nextNewLine = \",\\n\"\
\009\009\009\009subIndent = indent .. \" \"\
\009\009\009end\
\
\009\009\009local result, n = {(tupleLength and \"(\" or \"{\") .. newLine}, 1\
\
\009\009\009local seen = {}\
\009\009\009local first = true\
\009\009\009for k = 1, length do\
\009\009\009\009seen[k] = true\
\009\009\009\009n = n + 1\
\009\009\009\009local entry = subIndent .. dumpImpl(t[k], tracking, subIndent)\
\
\009\009\009\009if not first then\
\009\009\009\009\009entry = nextNewLine .. entry\
\009\009\009\009else\
\009\009\009\009\009first = false\
\009\009\009\009end\
\
\009\009\009\009result[n] = entry\
\009\009\009end\
\
\009\009\009for k,v in pairs(t) do\
\009\009\009\009if not seen[k] then\
\009\009\009\009\009local entry\
\009\009\009\009\009if type(k) == \"string\" and string.match( k, \"^[%a_][%a%d_]*$\" ) then\
\009\009\009\009\009\009entry = k .. \" = \" .. dumpImpl(v, tracking, subIndent)\
\009\009\009\009\009else\
\009\009\009\009\009\009entry = \"[\" .. dumpImpl(k, tracking, subIndent) .. \"] = \" .. dumpImpl(v, tracking, subIndent)\
\009\009\009\009\009end\
\
\009\009\009\009\009entry = subIndent .. entry\
\
\009\009\009\009\009if not first then\
\009\009\009\009\009\009entry = nextNewLine .. entry\
\009\009\009\009\009else\
\009\009\009\009\009\009first = false\
\009\009\009\009\009end\
\
\009\009\009\009\009n = n + 1\
\009\009\009\009\009result[n] = entry\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009n = n + 1\
\009\009\009result[n] = newLine .. indent .. (tupleLength and \")\" or \"}\")\
\009\009\009return table.concat(result)\
\009\009end\
\
\009elseif objType == \"string\" then\
\009\009return (string.format(\"%q\", t):gsub(\"\\\\\\n\", \"\\\\n\"))\
\009else\
\009\009return tostring(t)\
\009end\
end\
\
local function dump(t, n)\
\009return dumpImpl(t, {}, \"\", n)\
end\
\
local keywords = createLookup {\
\009\"and\", \"break\", \"do\", \"else\", \"elseif\", \"end\", \"false\",\
\009\"for\", \"function\", \"if\", \"in\", \"local\", \"nil\", \"not\", \"or\",\
\009\"repeat\", \"return\", \"then\", \"true\", \"until\", \"while\",\
}\
\
--- Internal serialiser\
-- @param object The object being serialised\
-- @tparam table tracking List of items being tracked\
-- @tparam Buffer buffer Buffer to append to\
-- @treturn Buffer The buffer passed\
local function internalSerialise(object, tracking, buffer)\
\009local sType = type(object)\
\009if sType == \"table\" then\
\009\009if tracking[object] then\
\009\009\009error(\"Cannot serialise table with recursive entries\", 1)\
\009\009end\
\009\009tracking[object] = true\
\
\009\009if next(object) == nil then\
\009\009\009buffer:append(\"{}\")\
\009\009else\
\009\009\009-- Other tables take more work\
\009\009\009buffer:append(\"{\")\
\
\009\009\009local seen = {}\
\009\009\009-- Attempt array only method\
\009\009\009for k, v in ipairs(object) do\
\009\009\009\009seen[k] = true\
\009\009\009\009internalSerialise(v, tracking, buffer)\
\009\009\009\009buffer:append(\",\")\
\009\009\009end\
\009\009\009for k, v in pairs(object) do\
\009\009\009\009if not seen[k] then\
\009\009\009\009\009if type(k) == \"string\" and not keywords[k] and k:match(\"^[%a_][%a%d_]*$\") then\
\009\009\009\009\009\009buffer:append(k .. \"=\")\
\009\009\009\009\009else\
\009\009\009\009\009\009buffer:append(\"[\")\
\009\009\009\009\009\009internalSerialise(k, tracking, buffer)\
\009\009\009\009\009\009buffer:append(\"]=\")\
\009\009\009\009\009end\
\
\009\009\009\009\009internalSerialise(v, tracking, buffer)\
\009\009\009\009\009buffer:append(\",\")\
\009\009\009\009end\
\009\009\009end\
\009\009\009buffer:append(\"}\")\
\009\009end\
\009elseif sType == \"string\" then\
\009\009buffer:append(format(\"%q\", object))\
\009elseif sType == \"number\" or sType == \"boolean\" or sType == \"nil\" then\
\009\009buffer:append(tostring(object))\
\009else\
\009\009error(\"Cannot serialise type \" .. sType)\
\009end\
\
\009return buffer\
end\
\
--- Used for serialising a data structure.\
--\
-- This does not handle recursive structures or functions.\
-- @param object The object to dump\
-- @treturn string The serialised string\
local function serialise(object)\
\009return internalSerialise(object, {}, Buffer()):toString()\
end\
\
local function unserialise(msg)\
\009local func = loadstring(\"return \" .. msg, \"unserialise-temp\", nil, {})\
\009if not func then return nil end\
\
\009local ok, res = pcall(func)\
\009return ok and res\
end\
--- @export\
return {\
\009serialise = serialise,\
\009unserialise = unserialise,\
\009deserialise = unserialise,\
\009dump = dump,\
}\
end\
preload[\"howl.lib.colored\"] = function(...)\
--- Print coloured strings\
-- @module howl.lib.utils\
\
local term = require \"howl.platform\".term\
\
--- Prints a string in a colour if colour is supported\
-- @tparam int color The colour to print\
-- @param ... Values to print\
local function printColor(color, ...)\
\009term.setColor(color)\
\009term.print(...)\
\009term.resetColor(color)\
end\
\
--- Writes a string in a colour if colour is supported\
-- @tparam int color The colour to print\
-- @tparam string text Values to print\
local function writeColor(color, text)\
\009term.setColor(color)\
\009term.write(text)\
\009term.resetColor(color)\
end\
\
return {\
\009printColor = printColor,\
\009writeColor = writeColor,\
}\
end\
preload[\"howl.lib.Buffer\"] = function(...)\
--- An optimised class for appending strings\
-- @classmod howl.lib.Buffer\
\
local concat = table.concat\
\
--- Append to this buffer\
-- @tparam string text\
-- @treturn Buffer The current buffer to allow chaining\
local function append(self, text)\
\009local n = self.n + 1\
\009self[n] = text\
\009self.n = n\
\009return self\
end\
\
--- Convert this buffer to a string\
-- @treturn string String representation of the buffer\
local function toString(self)\
\009return concat(self)\
end\
\
--- Create a new buffer\
-- @treturn Buffer The buffer\
return function()\
\009return {\
\009\009n = 0, append = append, toString = toString\
\009}\
end\
end\
preload[\"howl.lib.assert\"] = function(...)\
--- Assertion helpers\
-- @module howl.lib.assert\
\
local type, error, floor, select = type, error, select, math.floor\
\
local nativeAssert = assert\
local assert = setmetatable(\
\009{ assert = nativeAssert },\
\009{ __call = function(self, ...) return nativeAssert(...) end }\
)\
\
local function typeError(type, expected, message)\
\009if message then\
\009\009return error(message:format(type))\
\009else\
\009\009return error(expected .. \" expected, got \" .. type)\
\009end\
end\
\
function assert.type(value, expected, message)\
\009local t = type(value)\
\009if t ~= expected then\
\009\009return typeError(t, expected, message)\
\009end\
end\
\
local function argError(type, expected, func, index)\
\009return error(\"bad argument #\" .. index .. \" for \" .. func .. \" (expected \" .. expected .. \", got \" .. type .. \")\")\
end\
\
function assert.argType(value, expected, func, index)\
\009local t = type(value)\
\009if t ~= expected then\
\009\009return argError(t, expected, func, index)\
\009end\
end\
\
function assert.args(func, ...)\
\009local len = select('#', ...)\
\009local args = {...}\
\
\009for k = 1, len, 2 do\
\009\009local t = type(args[i])\
\009\009local expected = args[i + 1]\
\009\009if t ~= expected then\
\009\009\009return argError(t, expected, func, math.floor(k / 2))\
\009\009end\
\009end\
end\
\
assert.typeError = typeError\
assert.argError = argError\
\
function assert.class(value, expected, message)\
\009local t = type(value)\
\009if t ~= \"table\" or not value.isInstanceOf then\
\009\009return typeError(t, expected, message)\
\009elseif not value:isInstanceOf(expected) then\
\009\009return typeError(value.class.name, expected, message)\
\009end\
end\
\
return assert\
end\
preload[\"howl.lib.argparse\"] = function(...)\
--- Parses command line arguments\
-- @module howl.lib.argparse\
\
local colored = require \"howl.lib.colored\"\
\
--- Simple wrapper for Options\
-- @type Option\
local Option = {\
\009__index = function(self, func)\
\009\009return function(self, ...)\
\009\009\009local parser = self.parser\
\009\009\009local value = parser[func](parser, self.name, ...)\
\
\009\009\009if value == parser then return self end -- Allow chaining\
\009\009\009return value\
\009\009end\
\009end\
}\
\
--- Parses command line arguments\
-- @type Parser\
local Parser = {}\
\
--- Returns the value of a option\
-- @tparam string name The name of the option\
-- @tparam string|boolean default The default value (optional)\
-- @treturn string|boolean The value of the option\
function Parser:Get(name, default)\
\009local options = self.options\
\
\009local value = options[name]\
\009if value ~= nil then return value end\
\
\009local settings = self.settings[name]\
\009if settings then\
\009\009local aliases = settings.aliases\
\009\009if aliases then\
\009\009\009for _, alias in ipairs(aliases) do\
\009\009\009\009value = options[alias]\
\009\009\009\009if value ~= nil then return value end\
\009\009\009end\
\009\009end\
\
\009\009value = settings.default\
\009\009if value ~= nil then return value end\
\009end\
\
\
\009return default\
end\
\
--- Ensure a option exists, throw an error otherwise\
-- @tparam string name The name of the option\
-- @treturn string|boolean The resulting value\
function Parser:Ensure(name)\
\009local value = self:Get(name)\
\009if value == nil then\
\009\009error(name .. \" must be set\")\
\009end\
\009return value\
end\
\
--- Set the default value for an option\
-- @tparam string name The name of the options\
-- @tparam string|boolean value The default value\
-- @treturn Parser The current object\
function Parser:Default(name, value)\
\009if value == nil then value = true end\
\009self:_SetSetting(name, \"default\", value)\
\
\009self:_Changed()\
\009return self\
end\
\
--- Sets an alias for an option\
-- @tparam string name The name of the option\
-- @tparam string alias The alias of the option\
-- @treturn Parser The current object\
function Parser:Alias(name, alias)\
\009local settings = self.settings\
\009local currentSettings = settings[name]\
\009if currentSettings then\
\009\009local currentAliases = currentSettings.aliases\
\009\009if currentAliases == nil then\
\009\009\009currentSettings.aliases = { alias }\
\009\009else\
\009\009\009table.insert(currentAliases, alias)\
\009\009end\
\009else\
\009\009settings[name] = { aliases = { alias } }\
\009end\
\
\009self:_Changed()\
\009return self\
end\
\
--- Sets the description, and type for an option\
-- @tparam string name The name of the option\
-- @tparam string description The description of the option\
-- @treturn Parser The current object\
function Parser:Description(name, description)\
\009return self:_SetSetting(name, \"description\", description)\
end\
\
--- Sets if this option takes a value\
-- @tparam string name The name of the option\
-- @tparam boolean takesValue If the option takes a value\
-- @treturn Parser The current object\
function Parser:TakesValue(name, takesValue)\
\009if takesValue == nil then\
\009\009takesValue = true\
\009end\
\009return self:_SetSetting(name, \"takesValue\", takesValue)\
end\
\
--- Sets a setting for an option\
-- @tparam string name The name of the option\
-- @tparam string key The key of the setting\
-- @tparam boolean|string value The value of the setting\
-- @treturn Parser The current object\
-- @local\
function Parser:_SetSetting(name, key, value)\
\009local settings = self.settings\
\009local thisSettings = settings[name]\
\
\009if thisSettings then\
\009\009thisSettings[key] = value\
\009else\
\009\009settings[name] = { [key] = value }\
\009end\
\
\009return self\
end\
\
--- Creates a useful option helper object\
-- @tparam string name The name of the option\
-- @treturn Option The created option\
function Parser:Option(name)\
\009return setmetatable({\
\009\009name = name,\
\009\009parser = self\
\009}, Option)\
end\
\
--- Returns a list of arguments\
-- @treturn table The argument list\
function Parser:Arguments()\
\009return self.arguments\
end\
\
--- Fires the on changed event\
-- @local\
function Parser:_Changed()\
\009self.mediator:publish({ \"ArgParse\", \"changed\" }, self)\
end\
\
--- Generates a help string\
-- @tparam string indent The indent to print it at\
function Parser:Help(indent)\
\009for name, settings in pairs(self.settings) do\
\009\009local prefix = '-'\
\
\009\009-- If we take a value then we should say so\
\009\009if settings.takesValue then\
\009\009\009prefix = \"--\"\
\009\009\009name = name .. \"=value\"\
\009\009end\
\
\009\009-- If length is more than one then we should set\
\009\009-- the prefix to be --\
\009\009if #name > 1 then\
\009\009\009prefix = '--'\
\009\009end\
\
\009\009colored.writeColor(\"white\", indent .. prefix .. name)\
\
\009\009local aliasStr = \"\"\
\009\009local aliases = settings.aliases\
\009\009if aliases and #aliases > 0 then\
\009\009\009local aliasLength = #aliases\
\009\009\009aliasStr = aliasStr .. \" (\"\
\
\009\009\009for i = 1, aliasLength do\
\009\009\009\009local alias = \"-\" .. aliases[i]\
\
\009\009\009\009if #alias > 2 then -- \"-\" and another character\
\009\009\009\009\009alias = \"-\" .. alias\
\009\009\009\009end\
\
\009\009\009\009if i < aliasLength then\
\009\009\009\009\009alias = alias .. ', '\
\009\009\009\009end\
\
\009\009\009\009aliasStr = aliasStr .. alias\
\009\009\009end\
\009\009\009aliasStr = aliasStr .. \")\"\
\009\009end\
\
\009\009colored.writeColor(\"brown\", aliasStr)\
\009\009local description = settings.description\
\009\009if description and description ~= \"\" then\
\009\009\009colored.printColor(\"lightGray\", \" \" .. description)\
\009\009end\
\009end\
end\
\
--- Parse the options\
-- @treturn Parser The current object\
function Parser:Parse(args)\
\009local options = self.options\
\009local arguments = self.arguments\
\009for _, arg in ipairs(args) do\
\009\009if arg:sub(1, 1) == \"-\" then -- Match `-`\
\009\009\009if arg:sub(2, 2) == \"-\" then -- Match `--`\
\009\009\009\009local key, value = arg:match(\"([%w_%-]+)=([%w_%-]+)\", 3) -- Match [a-zA-Z0-9_-] in form key=value\
\009\009\009\009if key then\
\009\009\009\009\009options[key] = value\
\009\009\009\009else\
\009\009\009\009\009-- If it starts with not- or not_ then negate it\
\009\009\009\009\009arg = arg:sub(3)\
\009\009\009\009\009local beginning = arg:sub(1, 4)\
\009\009\009\009\009local value = true\
\009\009\009\009\009if beginning == \"not-\" or beginning == \"not_\" then\
\009\009\009\009\009\009value = false\
\009\009\009\009\009\009arg = arg:sub(5)\
\009\009\009\009\009end\
\009\009\009\009\009options[arg] = value\
\009\009\009\009end\
\009\009\009else -- Handle switches\
\009\009\009\009for i = 2, #arg do\
\009\009\009\009\009options[arg:sub(i, i)] = true\
\009\009\009\009end\
\009\009\009end\
\009\009else\
\009\009\009table.insert(arguments, arg)\
\009\009end\
\009end\
\
\009return self\
end\
\
--- Create a new options parser\
-- @tparam table mediator The mediator instance\
-- @tparam table args The command line arguments passed\
-- @treturn Parser The resulting parser\
local function Options(mediator, args)\
\009return setmetatable({\
\009\009options = {}, -- The resulting values\
\009\009arguments = {}, -- Spare arguments\
\009\009mediator = mediator,\
\
\009\009settings = {}, -- Settings for options\
\009}, { __index = Parser }):Parse(args)\
end\
\
--- @export\
return {\
\009Parser = Parser,\
\009Options = Options,\
}\
end\
preload[\"howl.lexer.walk\"] = function(...)\
local function terminate() end\
local function callExpr(node, visitor)\
\009visitor(node.Base)\
\009for _, v in ipairs(node.Arguments) do visitor(v) end\
end\
\
local function indexExpr(node, visitor)\
\009visitor(node.Base)\
\009visitor(node.Index)\
end\
\
local visitors\
\
local function visit(node, visitor)\
\009local traverse = visitors[node.AstType]\
\009if not traverse then\
\009\009error(\"No visitor for \" .. node.AstType)\
\009end\
\009traverse(node, visitor)\
end\
\
visitors = {\
\009VarExpr = terminate,\
\009NumberExpr = terminate,\
\009StringExpr = terminate,\
\009BooleanExpr = terminate,\
\009NilExpr = terminate,\
\009DotsExpr = terminate,\
\009Eof = terminate,\
\
\009BinopExpr = function(node, visitor)\
\009\009visitor(node.Lhs)\
\009\009visitor(node.Rhs)\
\009end,\
\
\009UnopExpr = function(node, visitor)\
\009\009visitor(node.Rhs)\
\009end,\
\
\009CallExpr = callExpr,\
\009TableCallExpr = callExpr,\
\009StringCallExpr = callExpr,\
\
\009IndexExpr = indexExpr,\
\009MemberExpr = indexExpr,\
\009Function = function(node, visitor)\
\009\009if node.Name and not node.IsLocal then visitor(node.Name) end\
\009\009visitor(node.Body)\
\009end,\
\
\009ConstructorExpr = function(node, visitor)\
\009\009for _, v in ipairs(node.EntryList) do\
\009\009\009if v.Type == \"Key\" then visitor(v.Key) end\
\009\009\009visitor(v.Value)\
\009\009end\
\009end,\
\
\009Parentheses = function(node, visitor)\
\009\009visitor(v.Inner)\
\009end,\
\
\009Statlist = function(node, visitor)\
\009\009for _, v in ipairs(node.Body) do\
\009\009\009visitor(v)\
\009\009end\
\009end,\
\
\009ReturnStatement = function(node, visitor)\
\009\009for _, v in ipairs(node.Arguments) do visitor(v) end\
\009end,\
\
\009AssignmentStatement = function(node, visitor)\
\009\009for _, v in ipairs(node.Lhs) do visitor(v) end\
\009\009for _, v in ipairs(node.Rhs) do visitor(v) end\
\009end,\
\
\009LocalStatement = function(node, visitor)\
\009\009for _, v in ipairs(node.InitList) do visitor(v) end\
\009end,\
\
\009CallStatement = function(node, visitor)\
\009\009visitor(v.Expression)\
\009end,\
\
\009IfStatement = function(node, visitor)\
\009\009for _, v in ipairs(node.Clauses) do\
\009\009\009if v.Condition then visitor(v.Condition) end\
\009\009\009visitor(v.Body)\
\009\009end\
\009end,\
\
\009WhileStatement = function(node, visitor)\
\009\009visitor(node.Condition)\
\009\009visitor(node.Body)\
\009end,\
\009DoStatement = function(node, visitor) visitor(node.Body) end,\
\009BreakStatement = terminate,\
\009LabelStatement = terminate,\
\009GotoStatement = terminate,\
\009RepeatStatement = function(node, visitor)\
\009\009visitor(node.Body)\
\009\009visitor(node.Condition)\
\009end,\
\
\009GenericForStatement = function(node, visitor)\
\009\009for _, v in ipairs(node.Generators) do visitor(v) end\
\009\009visitor(node.Body)\
\009end,\
\
\009NumericForStatement = function(node, visitor)\
\009\009visitor(node.Start)\
\009\009visitor(node.End)\
\009\009if node.Step then visitor(node.Step) end\
\009\009visitor(node.Body)\
\009end\
}\
\
return visit\
end\
preload[\"howl.lexer.TokenList\"] = function(...)\
--- Provides utilities for reading tokens from a 'stream'\
-- @module howl.lexer.TokenList\
\
local min = math.min\
local insert = table.insert\
\
return function(tokens)\
\009local n = #tokens\
\009local pointer = 1\
\
\009--- Get this element in the token list\
\009-- @tparam int offset The offset in the token list\
\009local function Peek(offset)\
\009\009return tokens[min(n, pointer + (offset or 0))]\
\009end\
\
\009--- Get the next token in the list\
\009-- @tparam table tokenList Add the token onto this table\
\009-- @treturn Token The token\
\009local function Get(tokenList)\
\009\009local token = tokens[pointer]\
\009\009pointer = min(pointer + 1, n)\
\009\009if tokenList then\
\009\009\009insert(tokenList, token)\
\009\009end\
\009\009return token\
\009end\
\
\009--- Check if the next token is of a type\
\009-- @tparam string type The type to compare it with\
\009-- @treturn bool If the type matches\
\009local function Is(type)\
\009\009return Peek().Type == type\
\009end\
\
\009--- Check if the next token is a symbol and return it\
\009-- @tparam string symbol Symbol to check (Optional)\
\009-- @tparam table tokenList Add the token onto this table\
\009-- @treturn [ 0 ] ?|token If symbol is not specified, return the token\
\009-- @treturn [ 1 ] boolean If symbol is specified, return true if it matches\
\009local function ConsumeSymbol(symbol, tokenList)\
\009\009local token = Peek()\
\009\009if token.Type == 'Symbol' then\
\009\009\009if symbol then\
\009\009\009\009if token.Data == symbol then\
\009\009\009\009\009if tokenList then insert(tokenList, token) end\
\009\009\009\009\009pointer = pointer + 1\
\009\009\009\009\009return true\
\009\009\009\009else\
\009\009\009\009\009return nil\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009if tokenList then insert(tokenList, token) end\
\009\009\009\009pointer = pointer + 1\
\009\009\009\009return token\
\009\009\009end\
\009\009else\
\009\009\009return nil\
\009\009end\
\009end\
\
\009--- Check if the next token is a keyword and return it\
\009-- @tparam string kw Keyword to check (Optional)\
\009-- @tparam table tokenList Add the token onto this table\
\009-- @treturn [ 0 ] ?|token If kw is not specified, return the token\
\009-- @treturn [ 1 ] boolean If kw is specified, return true if it matches\
\009local function ConsumeKeyword(kw, tokenList)\
\009\009local token = Peek()\
\009\009if token.Type == 'Keyword' and token.Data == kw then\
\009\009\009if tokenList then insert(tokenList, token) end\
\009\009\009pointer = pointer + 1\
\009\009\009return true\
\009\009else\
\009\009\009return nil\
\009\009end\
\009end\
\
\009--- Check if the next token matches is a keyword\
\009-- @tparam string kw The particular keyword\
\009-- @treturn boolean If it matches or not\
\009local function IsKeyword(kw)\
\009\009local token = Peek()\
\009\009return token.Type == 'Keyword' and token.Data == kw\
\009end\
\
\009--- Check if the next token matches is a symbol\
\009-- @tparam string symbol The particular symbol\
\009-- @treturn boolean If it matches or not\
\009local function IsSymbol(symbol)\
\009\009local token = Peek()\
\009\009return token.Type == 'Symbol' and token.Data == symbol\
\009end\
\
\009--- Check if the next token is an end of file\
\009-- @treturn boolean If the next token is an end of file\
\009local function IsEof()\
\009\009return Peek().Type == 'Eof'\
\009end\
\
\009--- Produce a string off all tokens\
\009-- @tparam boolean includeLeading Include the leading whitespace\
\009-- @treturn string The resulting string\
\009local function Print(includeLeading)\
\009\009includeLeading = (includeLeading == nil and true or includeLeading)\
\
\009\009local out = \"\"\
\009\009for _, token in ipairs(tokens) do\
\009\009\009if includeLeading then\
\009\009\009\009for _, whitespace in ipairs(token.LeadingWhite) do\
\009\009\009\009\009out = out .. whitespace:Print() .. \"\\n\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009out = out .. token:Print() .. \"\\n\"\
\009\009end\
\
\009\009return out\
\009end\
\
\009return {\
\009\009Peek = Peek,\
\009\009Get = Get,\
\009\009Is = Is,\
\009\009ConsumeSymbol = ConsumeSymbol,\
\009\009ConsumeKeyword = ConsumeKeyword,\
\009\009IsKeyword = IsKeyword,\
\009\009IsSymbol = IsSymbol,\
\009\009IsEof = IsEof,\
\009\009Print = Print,\
\009\009Tokens = tokens,\
\009}\
end\
end\
preload[\"howl.lexer.Scope\"] = function(...)\
--- Holds variables for one scope\
-- This implementation is inefficient. Instead of using hashes,\
-- a linear search is used instead to look up variables\
-- @module howl.lexer.Scope\
\
local keywords = require \"howl.lexer.constants\".Keywords\
\
--- Holds the data for one variable\
-- @table Variable\
-- @tfield Scope Scope The parent scope\
-- @tfield string Name The name of the variable\
-- @tfield boolean IsGlobal Is the variable global\
-- @tfield boolean CanRename If the variable can be renamed\
-- @tfield int References Number of references\
\
--- Holds variables for one scope\
-- @type Scope\
-- @tfield ?|Scope Parent The parent scope\
-- @tfield table Locals A list of locals variables\
-- @tfield table Globals A list of global variables\
-- @tfield table Children A list of children @{Scope|scopes}\
\
local Scope = {}\
\
--- Add a local to this scope\
-- @tparam Variable variable The local object\
function Scope:AddLocal(name, variable)\
\009table.insert(self.Locals, variable)\
\009self.LocalMap[name] = variable\
end\
\
--- Create a @{Variable} and add it to the scope\
-- @tparam string name The name of the local\
-- @treturn Variable The created local\
function Scope:CreateLocal(name)\
\009local variable = self:GetLocal(name)\
\009if variable then return variable end\
\
\009variable = {\
\009\009Scope = self,\
\009\009Name = name,\
\009\009IsGlobal = false,\
\009\009CanRename = true,\
\009\009References = 1,\
\009}\
\
\009self:AddLocal(name, variable)\
\009return variable\
end\
\
--- Get a local variable\
-- @tparam string name The name of the local\
-- @treturn ?|Variable The variable\
function Scope:GetLocal(name)\
\009repeat\
\009\009local var = self.LocalMap[name]\
\009\009if var then return var end\
\
\
\009\009self = self.Parent\
\009until not self\
end\
\
--- Find an local variable by its old name\
-- @tparam string name The old name of the local\
-- @treturn ?|Variable The local variable\
function Scope:GetOldLocal(name)\
\009if self.oldLocalNamesMap[name] then\
\009\009return self.oldLocalNamesMap[name]\
\009end\
\009return self:GetLocal(name)\
end\
\
--- Rename a local variable\
-- @tparam string|Variable oldName The old variable name\
-- @tparam string newName The new variable name\
function Scope:RenameLocal(oldName, newName)\
\009oldName = type(oldName) == 'string' and oldName or oldName.Name\
\
\009repeat\
\009\009local var = self.LocalMap[oldName]\
\009\009if var then\
\009\009\009var.Name = newName\
\009\009\009self.oldLocalNamesMap[oldName] = var\
\009\009\009self.LocalMap[oldName] = nil\
\009\009\009self.LocalMap[newName] = var\
\009\009\009break\
\009\009end\
\
\009\009self = self.Parent\
\009until not self\
end\
\
--- Add a global to this scope\
-- @tparam Variable name The name of the global\
function Scope:AddGlobal(name, variable)\
\009table.insert(self.Globals, variable)\
\009self.GlobalMap[name] = variable\
end\
\
--- Create a @{Variable} and add it to the scope\
-- @tparam string name The name of the global\
-- @treturn Variable The created global\
function Scope:CreateGlobal(name)\
\009local variable = self:GetGlobal(name)\
\009if variable then return variable end\
\
\009variable = {\
\009\009Scope = self,\
\009\009Name = name,\
\009\009IsGlobal = true,\
\009\009CanRename = true,\
\009\009References = 1,\
\009}\
\
\009self:AddGlobal(name, variable)\
\009return variable\
end\
\
--- Get a global variable\
-- @tparam string name The name of the global\
-- @treturn ?|Variable The variable\
function Scope:GetGlobal(name)\
\009repeat\
\009\009local var = self.GlobalMap[name]\
\009\009if var then return var end\
\
\
\009\009self = self.Parent\
\009until not self\
end\
\
--- Get a variable by name\
-- @tparam string name The name of the variable\
-- @treturn ?|Variable The found variable\
-- @fixme This is a very inefficient implementation, as with @{Scope:GetLocal} and @{Scope:GetGlocal}\
function Scope:GetVariable(name)\
\009return self:GetLocal(name) or self:GetGlobal(name)\
end\
\
--- Get all variables in the scope\
-- @treturn table A list of @{Variable|variables}\
function Scope:GetAllVariables()\
\009return self:getVars(true, self:getVars(true))\
end\
\
--- Get all variables\
-- @tparam boolean top If this values is the 'top' of the function stack\
-- @tparam table ret Table to fill with return values (optional)\
-- @treturn table The variables\
-- @local\
function Scope:getVars(top, ret)\
\009local ret = ret or {}\
\009if top then\
\009\009for _, v in pairs(self.Children) do\
\009\009\009v:getVars(true, ret)\
\009\009end\
\009else\
\009\009for _, v in pairs(self.Locals) do\
\009\009\009table.insert(ret, v)\
\009\009end\
\009\009for _, v in pairs(self.Globals) do\
\009\009\009table.insert(ret, v)\
\009\009end\
\009\009if self.Parent then\
\009\009\009self.Parent:getVars(false, ret)\
\009\009end\
\009end\
\009return ret\
end\
\
--- Rename all locals to smaller values\
-- @tparam string validNameChars All characters that can be used to make a variable name\
-- @fixme Some of the string generation happens a lot, this could be looked at\
function Scope:ObfuscateLocals(validNameChars)\
\009-- Use values sorted for letter frequency instead\
\009local startChars = validNameChars or \"etaoinshrdlucmfwypvbgkqjxz_ETAOINSHRDLUCMFWYPVBGKQJXZ\"\
\009local otherChars = validNameChars or \"etaoinshrdlucmfwypvbgkqjxz_0123456789ETAOINSHRDLUCMFWYPVBGKQJXZ\"\
\
\009local startCharsLength, otherCharsLength = #startChars, #otherChars\
\009local index = 0\
\009local floor = math.floor\
\009for _, var in pairs(self.Locals) do\
\009\009local name\
\
\009\009repeat\
\009\009\009if index < startCharsLength then\
\009\009\009\009index = index + 1\
\009\009\009\009name = startChars:sub(index, index)\
\009\009\009else\
\009\009\009\009if index < startCharsLength then\
\009\009\009\009\009index = index + 1\
\009\009\009\009\009name = startChars:sub(index, index)\
\009\009\009\009else\
\009\009\009\009\009local varIndex = floor(index / startCharsLength)\
\009\009\009\009\009local offset = index % startCharsLength\
\009\009\009\009\009name = startChars:sub(offset, offset)\
\
\009\009\009\009\009while varIndex > 0 do\
\009\009\009\009\009\009offset = varIndex % otherCharsLength\
\009\009\009\009\009\009name = otherChars:sub(offset, offset) .. name\
\009\009\009\009\009\009varIndex = floor(varIndex / otherCharsLength)\
\009\009\009\009\009end\
\009\009\009\009\009index = index + 1\
\009\009\009\009end\
\009\009\009end\
\009\009until not (keywords[name] or self:GetVariable(name))\
\009\009self:RenameLocal(var.Name, name)\
\009end\
end\
\
--- Converts the scope to a string\
-- No, it actually just returns '&lt;scope&gt;'\
-- @treturn string '&lt;scope&gt;'\
function Scope:ToString()\
\009return '<Scope>'\
end\
\
--- Create a new scope\
-- @tparam Scope parent The parent scope\
-- @treturn Scope The created scope\
local function NewScope(parent)\
\009local scope = setmetatable({\
\009\009Parent = parent,\
\009\009Locals = {},\
\009\009LocalMap = {},\
\009\009Globals = {},\
\009\009GlobalMap = {},\
\009\009oldLocalNamesMap = {},\
\009\009Children = {},\
\009}, { __index = Scope })\
\
\009if parent then\
\009\009table.insert(parent.Children, scope)\
\009end\
\
\009return scope\
end\
\
return NewScope\
end\
preload[\"howl.lexer.rebuild\"] = function(...)\
--- Rebuild source code from an AST\
-- Does not preserve whitespace\
-- @module howl.lexer.rebuild\
\
local constants = require \"howl.lexer.constants\"\
local parse = require \"howl.lexer.parse\"\
local platform = require \"howl.platform\"\
\
local lowerChars = constants.LowerChars\
local upperChars = constants.UpperChars\
local digits = constants.Digits\
local symbols = constants.Symbols\
\
--- Join two statements together\
-- @tparam string left The left statement\
-- @tparam string right The right statement\
-- @tparam string sep The string used to separate the characters\
-- @treturn string The joined strings\
local function doJoinStatements(left, right, sep)\
\009sep = sep or ' '\
\009local leftEnd, rightStart = left:sub(-1, -1), right:sub(1, 1)\
\009if upperChars[leftEnd] or lowerChars[leftEnd] or leftEnd == '_' then\
\009\009if not (rightStart == '_' or upperChars[rightStart] or lowerChars[rightStart] or digits[rightStart]) then\
\009\009\009--rightStart is left symbol, can join without seperation\
\009\009\009return left .. right\
\009\009else\
\009\009\009return left .. sep .. right\
\009\009end\
\009elseif digits[leftEnd] then\
\009\009if rightStart == '(' then\
\009\009\009--can join statements directly\
\009\009\009return left .. right\
\009\009elseif symbols[rightStart] then\
\009\009\009return left .. right\
\009\009else\
\009\009\009return left .. sep .. right\
\009\009end\
\009elseif leftEnd == '' then\
\009\009return left .. right\
\009else\
\009\009if rightStart == '(' then\
\009\009\009--don't want to accidentally call last statement, can't join directly\
\009\009\009return left .. sep .. right\
\009\009else\
\009\009\009return left .. right\
\009\009end\
\009end\
end\
\
--- Returns the minified version of an AST. Operations which are performed:\
--  - All comments and whitespace are ignored\
--  - All local variables are renamed\
-- @tparam Node ast The AST tree\
-- @treturn string The minified string\
-- @todo Ability to control minification level\
-- @todo Convert to a buffer\
local function minify(ast)\
\009local formatStatlist, formatExpr\
\009local count = 0\
\009local function joinStatements(left, right, sep)\
\009\009if count > 150 then\
\009\009\009count = 0\
\009\009\009return left .. \"\\n\" .. right\
\009\009else\
\009\009\009return doJoinStatements(left, right, sep)\
\009\009end\
\009end\
\
\009formatExpr = function(expr, precedence)\
\009\009local precedence = precedence or 0\
\009\009local currentPrecedence = 0\
\009\009local skipParens = false\
\009\009local out = \"\"\
\009\009if expr.AstType == 'VarExpr' then\
\009\009\009if expr.Variable then\
\009\009\009\009out = out .. expr.Variable.Name\
\009\009\009else\
\009\009\009\009out = out .. expr.Name\
\009\009\009end\
\
\009\009elseif expr.AstType == 'NumberExpr' then\
\009\009\009out = out .. expr.Value.Data\
\
\009\009elseif expr.AstType == 'StringExpr' then\
\009\009\009out = out .. expr.Value.Data\
\
\009\009elseif expr.AstType == 'BooleanExpr' then\
\009\009\009out = out .. tostring(expr.Value)\
\
\009\009elseif expr.AstType == 'NilExpr' then\
\009\009\009out = joinStatements(out, \"nil\")\
\
\009\009elseif expr.AstType == 'BinopExpr' then\
\009\009\009currentPrecedence = expr.OperatorPrecedence\
\009\009\009out = joinStatements(out, formatExpr(expr.Lhs, currentPrecedence))\
\009\009\009out = joinStatements(out, expr.Op)\
\009\009\009out = joinStatements(out, formatExpr(expr.Rhs))\
\009\009\009if expr.Op == '^' or expr.Op == '..' then\
\009\009\009\009currentPrecedence = currentPrecedence - 1\
\009\009\009end\
\
\009\009\009if currentPrecedence < precedence then\
\009\009\009\009skipParens = false\
\009\009\009else\
\009\009\009\009skipParens = true\
\009\009\009end\
\009\009elseif expr.AstType == 'UnopExpr' then\
\009\009\009out = joinStatements(out, expr.Op)\
\009\009\009out = joinStatements(out, formatExpr(expr.Rhs))\
\
\009\009elseif expr.AstType == 'DotsExpr' then\
\009\009\009out = out .. \"...\"\
\
\009\009elseif expr.AstType == 'CallExpr' then\
\009\009\009out = out .. formatExpr(expr.Base)\
\009\009\009out = out .. \"(\"\
\009\009\009for i = 1, #expr.Arguments do\
\009\009\009\009out = out .. formatExpr(expr.Arguments[i])\
\009\009\009\009if i ~= #expr.Arguments then\
\009\009\009\009\009out = out .. \",\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009out = out .. \")\"\
\
\009\009elseif expr.AstType == 'TableCallExpr' then\
\009\009\009out = out .. formatExpr(expr.Base)\
\009\009\009out = out .. formatExpr(expr.Arguments[1])\
\
\009\009elseif expr.AstType == 'StringCallExpr' then\
\009\009\009out = out .. formatExpr(expr.Base)\
\009\009\009out = out .. expr.Arguments[1].Data\
\
\009\009elseif expr.AstType == 'IndexExpr' then\
\009\009\009out = out .. formatExpr(expr.Base) .. \"[\" .. formatExpr(expr.Index) .. \"]\"\
\
\009\009elseif expr.AstType == 'MemberExpr' then\
\009\009\009out = out .. formatExpr(expr.Base) .. expr.Indexer .. expr.Ident.Data\
\
\009\009elseif expr.AstType == 'Function' then\
\009\009\009expr.Scope:ObfuscateLocals()\
\009\009\009out = out .. \"function(\"\
\009\009\009if #expr.Arguments > 0 then\
\009\009\009\009for i = 1, #expr.Arguments do\
\009\009\009\009\009out = out .. expr.Arguments[i].Name\
\009\009\009\009\009if i ~= #expr.Arguments then\
\009\009\009\009\009\009out = out .. \",\"\
\009\009\009\009\009elseif expr.VarArg then\
\009\009\009\009\009\009out = out .. \",...\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif expr.VarArg then\
\009\009\009\009out = out .. \"...\"\
\009\009\009end\
\009\009\009out = out .. \")\"\
\009\009\009out = joinStatements(out, formatStatlist(expr.Body))\
\009\009\009out = joinStatements(out, \"end\")\
\
\009\009elseif expr.AstType == 'ConstructorExpr' then\
\009\009\009out = out .. \"{\"\
\009\009\009for i = 1, #expr.EntryList do\
\009\009\009\009local entry = expr.EntryList[i]\
\009\009\009\009if entry.Type == 'Key' then\
\009\009\009\009\009out = out .. \"[\" .. formatExpr(entry.Key) .. \"]=\" .. formatExpr(entry.Value)\
\009\009\009\009elseif entry.Type == 'Value' then\
\009\009\009\009\009out = out .. formatExpr(entry.Value)\
\009\009\009\009elseif entry.Type == 'KeyString' then\
\009\009\009\009\009out = out .. entry.Key .. \"=\" .. formatExpr(entry.Value)\
\009\009\009\009end\
\009\009\009\009if i ~= #expr.EntryList then\
\009\009\009\009\009out = out .. \",\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009out = out .. \"}\"\
\
\009\009elseif expr.AstType == 'Parentheses' then\
\009\009\009out = out .. \"(\" .. formatExpr(expr.Inner) .. \")\"\
\009\009end\
\009\009if not skipParens then\
\009\009\009out = string.rep('(', expr.ParenCount or 0) .. out\
\009\009\009out = out .. string.rep(')', expr.ParenCount or 0)\
\009\009end\
\009\009count = count + #out\
\009\009return out\
\009end\
\
\009local formatStatement = function(statement)\
\009\009local out = ''\
\009\009if statement.AstType == 'AssignmentStatement' then\
\009\009\009for i = 1, #statement.Lhs do\
\009\009\009\009out = out .. formatExpr(statement.Lhs[i])\
\009\009\009\009if i ~= #statement.Lhs then\
\009\009\009\009\009out = out .. \",\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009if #statement.Rhs > 0 then\
\009\009\009\009out = out .. \"=\"\
\009\009\009\009for i = 1, #statement.Rhs do\
\009\009\009\009\009out = out .. formatExpr(statement.Rhs[i])\
\009\009\009\009\009if i ~= #statement.Rhs then\
\009\009\009\009\009\009out = out .. \",\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif statement.AstType == 'CallStatement' then\
\009\009\009out = formatExpr(statement.Expression)\
\
\009\009elseif statement.AstType == 'LocalStatement' then\
\009\009\009out = out .. \"local \"\
\009\009\009for i = 1, #statement.LocalList do\
\009\009\009\009out = out .. statement.LocalList[i].Name\
\009\009\009\009if i ~= #statement.LocalList then\
\009\009\009\009\009out = out .. \",\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009if #statement.InitList > 0 then\
\009\009\009\009out = out .. \"=\"\
\009\009\009\009for i = 1, #statement.InitList do\
\009\009\009\009\009out = out .. formatExpr(statement.InitList[i])\
\009\009\009\009\009if i ~= #statement.InitList then\
\009\009\009\009\009\009out = out .. \",\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif statement.AstType == 'IfStatement' then\
\009\009\009out = joinStatements(\"if\", formatExpr(statement.Clauses[1].Condition))\
\009\009\009out = joinStatements(out, \"then\")\
\009\009\009out = joinStatements(out, formatStatlist(statement.Clauses[1].Body))\
\009\009\009for i = 2, #statement.Clauses do\
\009\009\009\009local st = statement.Clauses[i]\
\009\009\009\009if st.Condition then\
\009\009\009\009\009out = joinStatements(out, \"elseif\")\
\009\009\009\009\009out = joinStatements(out, formatExpr(st.Condition))\
\009\009\009\009\009out = joinStatements(out, \"then\")\
\009\009\009\009else\
\009\009\009\009\009out = joinStatements(out, \"else\")\
\009\009\009\009end\
\009\009\009\009out = joinStatements(out, formatStatlist(st.Body))\
\009\009\009end\
\009\009\009out = joinStatements(out, \"end\")\
\
\009\009elseif statement.AstType == 'WhileStatement' then\
\009\009\009out = joinStatements(\"while\", formatExpr(statement.Condition))\
\009\009\009out = joinStatements(out, \"do\")\
\009\009\009out = joinStatements(out, formatStatlist(statement.Body))\
\009\009\009out = joinStatements(out, \"end\")\
\
\009\009elseif statement.AstType == 'DoStatement' then\
\009\009\009out = joinStatements(out, \"do\")\
\009\009\009out = joinStatements(out, formatStatlist(statement.Body))\
\009\009\009out = joinStatements(out, \"end\")\
\
\009\009elseif statement.AstType == 'ReturnStatement' then\
\009\009\009out = \"return\"\
\009\009\009for i = 1, #statement.Arguments do\
\009\009\009\009out = joinStatements(out, formatExpr(statement.Arguments[i]))\
\009\009\009\009if i ~= #statement.Arguments then\
\009\009\009\009\009out = out .. \",\"\
\009\009\009\009end\
\009\009\009end\
\
\009\009elseif statement.AstType == 'BreakStatement' then\
\009\009\009out = \"break\"\
\
\009\009elseif statement.AstType == 'RepeatStatement' then\
\009\009\009out = \"repeat\"\
\009\009\009out = joinStatements(out, formatStatlist(statement.Body))\
\009\009\009out = joinStatements(out, \"until\")\
\009\009\009out = joinStatements(out, formatExpr(statement.Condition))\
\
\009\009elseif statement.AstType == 'Function' then\
\009\009\009statement.Scope:ObfuscateLocals()\
\009\009\009if statement.IsLocal then\
\009\009\009\009out = \"local\"\
\009\009\009end\
\009\009\009out = joinStatements(out, \"function \")\
\009\009\009if statement.IsLocal then\
\009\009\009\009out = out .. statement.Name.Name\
\009\009\009else\
\009\009\009\009out = out .. formatExpr(statement.Name)\
\009\009\009end\
\009\009\009out = out .. \"(\"\
\009\009\009if #statement.Arguments > 0 then\
\009\009\009\009for i = 1, #statement.Arguments do\
\009\009\009\009\009out = out .. statement.Arguments[i].Name\
\009\009\009\009\009if i ~= #statement.Arguments then\
\009\009\009\009\009\009out = out .. \",\"\
\009\009\009\009\009elseif statement.VarArg then\
\009\009\009\009\009\009out = out .. \",...\"\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif statement.VarArg then\
\009\009\009\009out = out .. \"...\"\
\009\009\009end\
\009\009\009out = out .. \")\"\
\009\009\009out = joinStatements(out, formatStatlist(statement.Body))\
\009\009\009out = joinStatements(out, \"end\")\
\
\009\009elseif statement.AstType == 'GenericForStatement' then\
\009\009\009statement.Scope:ObfuscateLocals()\
\009\009\009out = \"for \"\
\009\009\009for i = 1, #statement.VariableList do\
\009\009\009\009out = out .. statement.VariableList[i].Name\
\009\009\009\009if i ~= #statement.VariableList then\
\009\009\009\009\009out = out .. \",\"\
\009\009\009\009end\
\009\009\009end\
\009\009\009out = out .. \" in\"\
\009\009\009for i = 1, #statement.Generators do\
\009\009\009\009out = joinStatements(out, formatExpr(statement.Generators[i]))\
\009\009\009\009if i ~= #statement.Generators then\
\009\009\009\009\009out = joinStatements(out, ',')\
\009\009\009\009end\
\009\009\009end\
\009\009\009out = joinStatements(out, \"do\")\
\009\009\009out = joinStatements(out, formatStatlist(statement.Body))\
\009\009\009out = joinStatements(out, \"end\")\
\
\009\009elseif statement.AstType == 'NumericForStatement' then\
\009\009\009statement.Scope:ObfuscateLocals()\
\009\009\009out = \"for \"\
\009\009\009out = out .. statement.Variable.Name .. \"=\"\
\009\009\009out = out .. formatExpr(statement.Start) .. \",\" .. formatExpr(statement.End)\
\009\009\009if statement.Step then\
\009\009\009\009out = out .. \",\" .. formatExpr(statement.Step)\
\009\009\009end\
\009\009\009out = joinStatements(out, \"do\")\
\009\009\009out = joinStatements(out, formatStatlist(statement.Body))\
\009\009\009out = joinStatements(out, \"end\")\
\009\009elseif statement.AstType == 'LabelStatement' then\
\009\009\009out = \"::\" .. statement.Label .. \"::\"\
\009\009elseif statement.AstType == 'GotoStatement' then\
\009\009\009out = \"goto \" .. statement.Label\
\009\009elseif statement.AstType == 'Comment' then\
\009\009\009-- ignore\
\009\009elseif statement.AstType == 'Eof' then\
\009\009\009-- ignore\
\009\009else\
\009\009\009error(\"Unknown AST Type: \" .. statement.AstType)\
\009\009end\
\009\009count = count + #out\
\009\009return out\
\009end\
\
\009formatStatlist = function(statList)\
\009\009local out = ''\
\009\009statList.Scope:ObfuscateLocals()\
\009\009for _, stat in pairs(statList.Body) do\
\009\009\009out = joinStatements(out, formatStatement(stat), ';')\
\009\009end\
\009\009return out\
\009end\
\
\009return formatStatlist(ast)\
end\
\
--- Minify a string\
-- @tparam string input The input string\
-- @treturn string The minifyied string\
local function minifyString(input)\
\009local lex = parse.LexLua(input)\
\009platform.refreshYield()\
\
\009local tree = parse.ParseLua(lex)\
\009platform.refreshYield()\
\
\009local min = minify(tree)\
\009platform.refreshYield()\
\009return min\
end\
\
--- Minify a file\
-- @tparam string cd Current directory\
-- @tparam string inputFile File to read from\
-- @tparam string outputFile File to write to (Defaults to inputFile)\
local function minifyFile(cd, inputFile, outputFile)\
\009outputFile = outputFile or inputFile\
\
\009local oldContents = platform.fs.read(platform.fs.combine(cd, inputFile))\
\009local newContents = minifyString(oldContents)\
\
\009platform.fs.write(platform.fs.combine(cd, outputFile), newContents)\
\009return #oldContents, #newContents\
end\
\
--- @export\
return {\
\009minify = minify,\
\009minifyString = minifyString,\
\009minifyFile = minifyFile,\
}\
end\
preload[\"howl.lexer.parse\"] = function(...)\
--- The main lua parser and lexer.\
-- LexLua returns a Lua token stream, with tokens that preserve\
-- all whitespace formatting information.\
-- ParseLua returns an AST, internally relying on LexLua.\
-- @module howl.lexer.parse\
\
local Constants = require \"howl.lexer.constants\"\
local Scope = require \"howl.lexer.Scope\"\
local TokenList = require \"howl.lexer.TokenList\"\
\
local lowerChars = Constants.LowerChars\
local upperChars = Constants.UpperChars\
local digits = Constants.Digits\
local symbols = Constants.Symbols\
local hexDigits = Constants.HexDigits\
local keywords = Constants.Keywords\
local statListCloseKeywords = Constants.StatListCloseKeywords\
local unops = Constants.UnOps\
local insert, setmeta = table.insert, setmetatable\
\
--- One token\
-- @table Token\
-- @tparam string Type The token type\
-- @param Data Data about the token\
-- @tparam string CommentType The type of comment  (Optional)\
-- @tparam number Line Line number (Optional)\
-- @tparam number Char Character number (Optional)\
local Token = {}\
\
--- Creates a string representation of the token\
-- @treturn string The resulting string\
function Token:Print()\
\009return \"<\"..(self.Type .. string.rep(' ', math.max(3, 12-#self.Type)))..\"  \"..(self.Data or '')..\" >\"\
end\
\
local tokenMeta = { __index = Token }\
\
--- Create a list of @{Token|tokens} from a Lua source\
-- @tparam string src Lua source code\
-- @treturn TokenList The list of @{Token|tokens}\
local function LexLua(src)\
\009--token dump\
\009local tokens = {}\
\
\009do -- Main bulk of the work\
\009\009local sub = string.sub\
\
\009\009--line / char / pointer tracking\
\009\009local pointer = 1\
\009\009local line = 1\
\009\009local char = 1\
\
\009\009--get / peek functions\
\009\009local function get()\
\009\009\009local c = sub(src, pointer,pointer)\
\009\009\009if c == '\\n' then\
\009\009\009\009char = 1\
\009\009\009\009line = line + 1\
\009\009\009else\
\009\009\009\009char = char + 1\
\009\009\009end\
\009\009\009pointer = pointer + 1\
\009\009\009return c\
\009\009end\
\
\009\009local function peek(n)\
\009\009\009n = n or 0\
\009\009\009return sub(src, pointer+n,pointer+n)\
\009\009end\
\009\009local function consume(chars)\
\009\009\009local c = peek()\
\009\009\009for i = 1, #chars do\
\009\009\009\009if c == chars:sub(i,i) then return get() end\
\009\009\009end\
\009\009end\
\
\009\009--shared stuff\
\009\009local function generateError(err)\
\009\009\009error(\">> :\"..line..\":\"..char..\": \"..err, 0)\
\009\009end\
\
\009\009local function tryGetLongString()\
\009\009\009local start = pointer\
\009\009\009if peek() == '[' then\
\009\009\009\009local equalsCount = 0\
\009\009\009\009local depth = 1\
\009\009\009\009while peek(equalsCount+1) == '=' do\
\009\009\009\009\009equalsCount = equalsCount + 1\
\009\009\009\009end\
\009\009\009\009if peek(equalsCount+1) == '[' then\
\009\009\009\009\009--start parsing the string. Strip the starting bit\
\009\009\009\009\009for _ = 0, equalsCount+1 do get() end\
\
\009\009\009\009\009--get the contents\
\009\009\009\009\009local contentStart = pointer\
\009\009\009\009\009while true do\
\009\009\009\009\009\009--check for eof\
\009\009\009\009\009\009if peek() == '' then\
\009\009\009\009\009\009\009generateError(\"Expected `]\"..string.rep('=', equalsCount)..\"]` near <eof>.\", 3)\
\009\009\009\009\009\009end\
\
\009\009\009\009\009\009--check for the end\
\009\009\009\009\009\009local foundEnd = true\
\009\009\009\009\009\009if peek() == ']' then\
\009\009\009\009\009\009\009for i = 1, equalsCount do\
\009\009\009\009\009\009\009\009if peek(i) ~= '=' then foundEnd = false end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009if peek(equalsCount+1) ~= ']' then\
\009\009\009\009\009\009\009\009foundEnd = false\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009if peek() == '[' then\
\009\009\009\009\009\009\009\009-- is there an embedded long string?\
\009\009\009\009\009\009\009\009local embedded = true\
\009\009\009\009\009\009\009\009for i = 1, equalsCount do\
\009\009\009\009\009\009\009\009\009if peek(i) ~= '=' then\
\009\009\009\009\009\009\009\009\009\009embedded = false\
\009\009\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009if peek(equalsCount + 1) == '[' and embedded then\
\009\009\009\009\009\009\009\009\009-- oh look, there was\
\009\009\009\009\009\009\009\009\009depth = depth + 1\
\009\009\009\009\009\009\009\009\009for i = 1, (equalsCount + 2) do\
\009\009\009\009\009\009\009\009\009\009get()\
\009\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009foundEnd = false\
\009\009\009\009\009\009end\
\
\009\009\009\009\009\009if foundEnd then\
\009\009\009\009\009\009\009depth = depth - 1\
\009\009\009\009\009\009\009if depth == 0 then\
\009\009\009\009\009\009\009\009break\
\009\009\009\009\009\009\009else\
\009\009\009\009\009\009\009\009for i = 1, equalsCount + 2 do\
\009\009\009\009\009\009\009\009\009get()\
\009\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009get()\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\
\009\009\009\009\009--get the interior string\
\009\009\009\009\009local contentString = src:sub(contentStart, pointer-1)\
\
\009\009\009\009\009--found the end. Get rid of the trailing bit\
\009\009\009\009\009for i = 0, equalsCount+1 do get() end\
\
\009\009\009\009\009--get the exterior string\
\009\009\009\009\009local longString = src:sub(start, pointer-1)\
\
\009\009\009\009\009--return the stuff\
\009\009\009\009\009return contentString, longString\
\009\009\009\009else\
\009\009\009\009\009return nil\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009return nil\
\009\009\009end\
\009\009end\
\
\009\009local function isDigit(c) return c >= '0' and c <= '9' end\
\
\009\009--main token emitting loop\
\009\009while true do\
\009\009\009--get leading whitespace. The leading whitespace will include any comments\
\009\009\009--preceding the token. This prevents the parser needing to deal with comments\
\009\009\009--separately.\
\009\009\009local comments, cn\
\009\009\009while true do\
\009\009\009\009local c = sub(src, pointer, pointer)\
\009\009\009\009if c == '#' and peek(1) == '!' and line == 1 then\
\009\009\009\009\009-- #! shebang for linux scripts\
\009\009\009\009\009get()\
\009\009\009\009\009get()\
\009\009\009\009\009leadingWhite = \"#!\"\
\009\009\009\009\009while peek() ~= '\\n' and peek() ~= '' do\
\009\009\009\009\009\009get()\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009if c == ' ' or c == '\\t' then\
\009\009\009\009\009--whitespace\
\009\009\009\009\009char = char + 1\
\009\009\009\009\009pointer = pointer + 1\
\009\009\009\009elseif c == '\\n' or c == '\\r' then\
\009\009\009\009\009char = 1\
\009\009\009\009\009line = line + 1\
\009\009\009\009\009pointer = pointer + 1\
\009\009\009\009elseif c == '-' and peek(1) == '-' then\
\009\009\009\009\009--comment\
\009\009\009\009\009get()\
\009\009\009\009\009get()\
\009\009\009\009\009local startLine, startChar, startPointer = line, char, pointer\
\009\009\009\009\009local wholeText, _ = tryGetLongString()\
\009\009\009\009\009if not wholeText then\
\009\009\009\009\009\009local next = sub(src, pointer, pointer)\
\009\009\009\009\009\009while next ~= '\\n' and next ~= '' do\
\009\009\009\009\009\009\009get()\
\009\009\009\009\009\009\009next = sub(src, pointer, pointer)\
\009\009\009\009\009\009end\
\009\009\009\009\009\009wholeText = sub(src, startPointer, pointer - 1)\
\009\009\009\009\009end\
\009\009\009\009\009if not comments then\
\009\009\009\009\009\009comments = {}\
\009\009\009\009\009\009cn = 0\
\009\009\009\009\009end\
\009\009\009\009\009cn = cn + 1\
\009\009\009\009\009comments[cn] = {\
\009\009\009\009\009\009Data = wholeText,\
\009\009\009\009\009\009Line = startLine,\
\009\009\009\009\009\009Char = startChar,\
\009\009\009\009\009}\
\009\009\009\009else\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009--get the initial char\
\009\009\009local thisLine = line\
\009\009\009local thisChar = char\
\009\009\009local c = sub(src, pointer, pointer)\
\
\009\009\009--symbol to emit\
\009\009\009local toEmit = nil\
\
\009\009\009--branch on type\
\009\009\009if c == '' then\
\009\009\009\009--eof\
\009\009\009\009toEmit = { Type = 'Eof' }\
\
\009\009\009elseif (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z') or c == '_' then\
\009\009\009\009--ident or keyword\
\009\009\009\009local start = pointer\
\009\009\009\009repeat\
\009\009\009\009\009get()\
\009\009\009\009\009c = sub(src, pointer, pointer)\
\009\009\009\009until not ((c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z') or c == '_' or (c >= '0' and c <= '9'))\
\009\009\009\009local dat = src:sub(start, pointer-1)\
\009\009\009\009if keywords[dat] then\
\009\009\009\009\009toEmit = {Type = 'Keyword', Data = dat}\
\009\009\009\009else\
\009\009\009\009\009toEmit = {Type = 'Ident', Data = dat}\
\009\009\009\009end\
\
\009\009\009elseif (c >= '0' and c <= '9') or (c == '.' and digits[peek(1)]) then\
\009\009\009\009--number const\
\009\009\009\009local start = pointer\
\009\009\009\009if c == '0' and peek(1) == 'x' then\
\009\009\009\009\009get();get()\
\009\009\009\009\009while hexDigits[peek()] do get() end\
\009\009\009\009\009if consume('Pp') then\
\009\009\009\009\009\009consume('+-')\
\009\009\009\009\009\009while digits[peek()] do get() end\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009while digits[peek()] do get() end\
\009\009\009\009\009if consume('.') then\
\009\009\009\009\009\009while digits[peek()] do get() end\
\009\009\009\009\009end\
\009\009\009\009\009if consume('Ee') then\
\009\009\009\009\009\009consume('+-')\
\
\009\009\009\009\009\009if not digits[peek()] then generateError(\"Expected exponent\") end\
\009\009\009\009\009\009repeat get() until not digits[peek()]\
\009\009\009\009\009end\
\
\009\009\009\009\009local n = peek():lower()\
\009\009\009\009\009if (n >= 'a' and n <= 'z') or n == '_' then\
\009\009\009\009\009\009generateError(\"Invalid number format\")\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009toEmit = {Type = 'Number', Data = src:sub(start, pointer-1)}\
\
\009\009\009elseif c == '\\'' or c == '\\\"' then\
\009\009\009\009local start = pointer\
\009\009\009\009--string const\
\009\009\009\009local delim = get()\
\009\009\009\009local contentStart = pointer\
\009\009\009\009while true do\
\009\009\009\009\009local c = get()\
\009\009\009\009\009if c == '\\\\' then\
\009\009\009\009\009\009get() --get the escape char\
\009\009\009\009\009elseif c == delim then\
\009\009\009\009\009\009break\
\009\009\009\009\009elseif c == '' then\
\009\009\009\009\009\009generateError(\"Unfinished string near <eof>\")\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009local content = src:sub(contentStart, pointer-2)\
\009\009\009\009local constant = src:sub(start, pointer-1)\
\009\009\009\009toEmit = {Type = 'String', Data = constant, Constant = content}\
\
\009\009\009elseif c == '[' then\
\009\009\009\009local content, wholetext = tryGetLongString()\
\009\009\009\009if wholetext then\
\009\009\009\009\009toEmit = {Type = 'String', Data = wholetext, Constant = content}\
\009\009\009\009else\
\009\009\009\009\009get()\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = '['}\
\009\009\009\009end\
\
\009\009\009elseif c == '>' or c == '<' or c == '=' then\
\009\009\009\009get()\
\009\009\009\009if consume('=') then\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = c..'='}\
\009\009\009\009else\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = c}\
\009\009\009\009end\
\
\009\009\009elseif c == '~' then\
\009\009\009\009get()\
\009\009\009\009if consume('=') then\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = '~='}\
\009\009\009\009else\
\009\009\009\009\009generateError(\"Unexpected symbol `~` in source.\", 2)\
\009\009\009\009end\
\
\009\009\009elseif c == '.' then\
\009\009\009\009get()\
\009\009\009\009if consume('.') then\
\009\009\009\009\009if consume('.') then\
\009\009\009\009\009\009toEmit = {Type = 'Symbol', Data = '...'}\
\009\009\009\009\009else\
\009\009\009\009\009\009toEmit = {Type = 'Symbol', Data = '..'}\
\009\009\009\009\009end\
\009\009\009\009else\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = '.'}\
\009\009\009\009end\
\
\009\009\009elseif c == ':' then\
\009\009\009\009get()\
\009\009\009\009if consume(':') then\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = '::'}\
\009\009\009\009else\
\009\009\009\009\009toEmit = {Type = 'Symbol', Data = ':'}\
\009\009\009\009end\
\
\009\009\009elseif symbols[c] then\
\009\009\009\009get()\
\009\009\009\009toEmit = {Type = 'Symbol', Data = c}\
\
\009\009\009else\
\009\009\009\009local contents, all = tryGetLongString()\
\009\009\009\009if contents then\
\009\009\009\009\009toEmit = {Type = 'String', Data = all, Constant = contents}\
\009\009\009\009else\
\009\009\009\009\009generateError(\"Unexpected Symbol `\"..c..\"` in source.\", 2)\
\009\009\009\009end\
\009\009\009end\
\
\009\009\009--add the emitted symbol, after adding some common data\
\009\009\009toEmit.Line = thisLine\
\009\009\009toEmit.Char = thisChar\
\009\009\009if comments then toEmit.Comments = comments end\
\009\009\009tokens[#tokens+1] = toEmit\
\
\009\009\009--halt after eof has been emitted\
\009\009\009if toEmit.Type == 'Eof' then break end\
\009\009end\
\009end\
\
\009--public interface:\
\009local tokenList = TokenList(tokens)\
\
\009return tokenList\
end\
\
--- Create a AST tree from a Lua Source\
-- @tparam TokenList tok List of tokens from @{LexLua}\
-- @treturn table The AST tree\
local function ParseLua(tok, src)\
\009--- Generate an error\
\009-- @tparam string msg The error message\
\009-- @raise The produces error message\
\009local function GenerateError(msg)\
\009\009local err = tok.Peek().Line..\":\"..tok.Peek().Char..\": \"..msg..\"\\n\"\
\009\009local peek = tok.Peek()\
\009\009err = err.. \" got \" .. peek.Type .. \": \" .. peek.Data.. \"\\n\"\
\009\009--find the line\
\009\009local lineNum = 0\
\009\009if type(src) == 'string' then\
\009\009\009for line in src:gmatch(\"[^\\n]*\\n?\") do\
\009\009\009\009if line:sub(-1,-1) == '\\n' then line = line:sub(1,-2) end\
\009\009\009\009lineNum = lineNum+1\
\009\009\009\009if lineNum == tok.Peek().Line then\
\009\009\009\009\009err = err..\"\"..line:gsub('\\t','    ')..\"\\n\"\
\009\009\009\009\009for i = 1, tok.Peek().Char do\
\009\009\009\009\009\009local c = line:sub(i,i)\
\009\009\009\009\009\009err = err..' '\
\009\009\009\009\009end\
\009\009\009\009\009err = err..\"^\"\
\009\009\009\009\009break\
\009\009\009\009end\
\009\009\009end\
\009\009end\
\009\009error(err)\
\009end\
\
\009local ParseExpr,\
\009      ParseStatementList,\
\009      ParseSimpleExpr,\
\009      ParsePrimaryExpr,\
\009      ParseSuffixedExpr\
\
\009--- Parse the function definition and its arguments\
\009-- @tparam Scope.Scope scope The current scope\
\009-- @tparam table tokenList A table to fill with tokens\
\009-- @treturn Node A function Node\
\009local function ParseFunctionArgsAndBody(scope, tokenList)\
\009\009local funcScope = Scope(scope)\
\009\009if not tok.ConsumeSymbol('(', tokenList) then\
\009\009\009GenerateError(\"`(` expected.\")\
\009\009end\
\
\009\009--arg list\
\009\009local argList = {}\
\009\009local isVarArg = false\
\009\009while not tok.ConsumeSymbol(')', tokenList) do\
\009\009\009if tok.Is('Ident') then\
\009\009\009\009local arg = funcScope:CreateLocal(tok.Get(tokenList).Data)\
\009\009\009\009argList[#argList+1] = arg\
\009\009\009\009if not tok.ConsumeSymbol(',', tokenList) then\
\009\009\009\009\009if tok.ConsumeSymbol(')', tokenList) then\
\009\009\009\009\009\009break\
\009\009\009\009\009else\
\009\009\009\009\009\009GenerateError(\"`)` expected.\")\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif tok.ConsumeSymbol('...', tokenList) then\
\009\009\009\009isVarArg = true\
\009\009\009\009if not tok.ConsumeSymbol(')', tokenList) then\
\009\009\009\009\009GenerateError(\"`...` must be the last argument of a function.\")\
\009\009\009\009end\
\009\009\009\009break\
\009\009\009else\
\009\009\009\009GenerateError(\"Argument name or `...` expected\")\
\009\009\009end\
\009\009end\
\
\009\009--body\
\009\009local body = ParseStatementList(funcScope)\
\
\009\009--end\
\009\009if not tok.ConsumeKeyword('end', tokenList) then\
\009\009\009GenerateError(\"`end` expected after function body\")\
\009\009end\
\
\009\009return {\
\009\009\009AstType   = 'Function',\
\009\009\009Scope     = funcScope,\
\009\009\009Arguments = argList,\
\009\009\009Body      = body,\
\009\009\009VarArg    = isVarArg,\
\009\009\009Tokens    = tokenList,\
\009\009}\
\009end\
\
\009--- Parse a simple expression\
\009-- @tparam Scope.Scope scope The current scope\
\009-- @treturn Node the resulting node\
\009function ParsePrimaryExpr(scope)\
\009\009local tokenList = {}\
\
\009\009if tok.ConsumeSymbol('(', tokenList) then\
\009\009\009local ex = ParseExpr(scope)\
\009\009\009if not tok.ConsumeSymbol(')', tokenList) then\
\009\009\009\009GenerateError(\"`)` Expected.\")\
\009\009\009end\
\
\009\009\009return {\
\009\009\009\009AstType = 'Parentheses',\
\009\009\009\009Inner   = ex,\
\009\009\009\009Tokens  = tokenList,\
\009\009\009}\
\
\009\009elseif tok.Is('Ident') then\
\009\009\009local id = tok.Get(tokenList)\
\009\009\009local var = scope:GetLocal(id.Data)\
\009\009\009if not var then\
\009\009\009\009var = scope:GetGlobal(id.Data)\
\009\009\009\009if not var then\
\009\009\009\009\009var = scope:CreateGlobal(id.Data)\
\009\009\009\009else\
\009\009\009\009\009var.References = var.References + 1\
\009\009\009\009end\
\009\009\009else\
\009\009\009\009var.References = var.References + 1\
\009\009\009end\
\
\009\009\009return {\
\009\009\009\009AstType  = 'VarExpr',\
\009\009\009\009Name     = id.Data,\
\009\009\009\009Variable = var,\
\009\009\009\009Tokens   = tokenList,\
\009\009\009}\
\009\009else\
\009\009\009GenerateError(\"primary expression expected\")\
\009\009end\
\009end\
\
\009--- Parse some table related expressions\
\009-- @tparam Scope.Scope scope The current scope\
\009-- @tparam boolean onlyDotColon Only allow '.' or ':' nodes\
\009-- @treturn Node The resulting node\
\009function ParseSuffixedExpr(scope, onlyDotColon)\
\009\009--base primary expression\
\009\009local prim = ParsePrimaryExpr(scope)\
\
\009\009while true do\
\009\009\009local tokenList = {}\
\
\009\009\009if tok.IsSymbol('.') or tok.IsSymbol(':') then\
\009\009\009\009local symb = tok.Get(tokenList).Data\
\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009GenerateError(\"<Ident> expected.\")\
\009\009\009\009end\
\009\009\009\009local id = tok.Get(tokenList)\
\
\009\009\009\009prim = {\
\009\009\009\009\009AstType  = 'MemberExpr',\
\009\009\009\009\009Base     = prim,\
\009\009\009\009\009Indexer  = symb,\
\009\009\009\009\009Ident    = id,\
\009\009\009\009\009Tokens   = tokenList,\
\009\009\009\009}\
\
\009\009\009elseif not onlyDotColon and tok.ConsumeSymbol('[', tokenList) then\
\009\009\009\009local ex = ParseExpr(scope)\
\009\009\009\009if not tok.ConsumeSymbol(']', tokenList) then\
\009\009\009\009\009GenerateError(\"`]` expected.\")\
\009\009\009\009end\
\
\009\009\009\009prim = {\
\009\009\009\009\009AstType  = 'IndexExpr',\
\009\009\009\009\009Base     = prim,\
\009\009\009\009\009Index    = ex,\
\009\009\009\009\009Tokens   = tokenList,\
\009\009\009\009}\
\
\009\009\009elseif not onlyDotColon and tok.ConsumeSymbol('(', tokenList) then\
\009\009\009\009local args = {}\
\009\009\009\009while not tok.ConsumeSymbol(')', tokenList) do\
\009\009\009\009\009args[#args+1] = ParseExpr(scope)\
\009\009\009\009\009if not tok.ConsumeSymbol(',', tokenList) then\
\009\009\009\009\009\009if tok.ConsumeSymbol(')', tokenList) then\
\009\009\009\009\009\009\009break\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009GenerateError(\"`)` Expected.\")\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\
\009\009\009\009prim = {\
\009\009\009\009\009AstType   = 'CallExpr',\
\009\009\009\009\009Base      = prim,\
\009\009\009\009\009Arguments = args,\
\009\009\009\009\009Tokens    = tokenList,\
\009\009\009\009}\
\
\009\009\009elseif not onlyDotColon and tok.Is('String') then\
\009\009\009\009--string call\
\009\009\009\009prim = {\
\009\009\009\009\009AstType    = 'StringCallExpr',\
\009\009\009\009\009Base       = prim,\
\009\009\009\009\009Arguments  = { tok.Get(tokenList) },\
\009\009\009\009\009Tokens     = tokenList,\
\009\009\009\009}\
\
\009\009\009elseif not onlyDotColon and tok.IsSymbol('{') then\
\009\009\009\009--table call\
\009\009\009\009local ex = ParseSimpleExpr(scope)\
\009\009\009\009-- FIX: ParseExpr(scope) parses the table AND and any following binary expressions.\
\009\009\009\009-- We just want the table\
\
\009\009\009\009prim = {\
\009\009\009\009\009AstType   = 'TableCallExpr',\
\009\009\009\009\009Base      = prim,\
\009\009\009\009\009Arguments = { ex },\
\009\009\009\009\009Tokens    = tokenList,\
\009\009\009\009}\
\
\009\009\009else\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\009\009return prim\
\009end\
\
\009--- Parse a simple expression (strings, numbers, booleans, varargs)\
\009-- @tparam Scope.Scope scope The current scope\
\009-- @treturn Node The resulting node\
\009function ParseSimpleExpr(scope)\
\009\009local tokenList = {}\
\
\009\009local next = tok.Peek()\
\009\009local type = next.Type\
\009\009if type == 'Number' then\
\009\009\009return {\
\009\009\009\009AstType = 'NumberExpr',\
\009\009\009\009Value   = tok.Get(tokenList),\
\009\009\009\009Tokens  = tokenList,\
\009\009\009}\
\009\009elseif type == 'String' then\
\009\009\009return {\
\009\009\009\009AstType = 'StringExpr',\
\009\009\009\009Value   = tok.Get(tokenList),\
\009\009\009\009Tokens  = tokenList,\
\009\009\009}\
\009\009elseif type == 'Keyword' then\
\009\009\009local data = next.Data\
\009\009\009if data == 'nil' then\
\009\009\009\009tok.Get(tokenList)\
\009\009\009\009return {\
\009\009\009\009\009AstType = 'NilExpr',\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\009\009\009elseif data == 'false' or data == 'true' then\
\009\009\009\009return {\
\009\009\009\009\009AstType = 'BooleanExpr',\
\009\009\009\009\009Value   = (tok.Get(tokenList).Data == 'true'),\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\009\009\009elseif data == 'function' then\
\009\009\009\009tok.Get(tokenList)\
\009\009\009\009local func = ParseFunctionArgsAndBody(scope, tokenList)\
\
\009\009\009\009func.IsLocal = true\
\009\009\009\009return func\
\009\009\009end\
\009\009elseif type == 'Symbol' then\
\009\009\009local data = next.Data\
\009\009\009if data == '...' then\
\009\009\009\009tok.Get(tokenList)\
\009\009\009\009return {\
\009\009\009\009\009AstType  = 'DotsExpr',\
\009\009\009\009\009Tokens   = tokenList,\
\009\009\009\009}\
\009\009\009elseif data == '{' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009local entryList = {}\
\009\009\009\009local v = {\
\009\009\009\009\009AstType = 'ConstructorExpr',\
\009\009\009\009\009EntryList = entryList,\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\
\009\009\009\009while true do\
\009\009\009\009\009if tok.IsSymbol('[', tokenList) then\
\009\009\009\009\009\009--key\
\009\009\009\009\009\009tok.Get(tokenList)\
\009\009\009\009\009\009local key = ParseExpr(scope)\
\009\009\009\009\009\009if not tok.ConsumeSymbol(']', tokenList) then\
\009\009\009\009\009\009\009GenerateError(\"`]` Expected\")\
\009\009\009\009\009\009end\
\009\009\009\009\009\009if not tok.ConsumeSymbol('=', tokenList) then\
\009\009\009\009\009\009\009GenerateError(\"`=` Expected\")\
\009\009\009\009\009\009end\
\009\009\009\009\009\009local value = ParseExpr(scope)\
\009\009\009\009\009\009entryList[#entryList+1] = {\
\009\009\009\009\009\009\009Type  = 'Key',\
\009\009\009\009\009\009\009Key   = key,\
\009\009\009\009\009\009\009Value = value,\
\009\009\009\009\009\009}\
\
\009\009\009\009\009elseif tok.Is('Ident') then\
\009\009\009\009\009\009--value or key\
\009\009\009\009\009\009local lookahead = tok.Peek(1)\
\009\009\009\009\009\009if lookahead.Type == 'Symbol' and lookahead.Data == '=' then\
\009\009\009\009\009\009\009--we are a key\
\009\009\009\009\009\009\009local key = tok.Get(tokenList)\
\009\009\009\009\009\009\009if not tok.ConsumeSymbol('=', tokenList) then\
\009\009\009\009\009\009\009\009GenerateError(\"`=` Expected\")\
\009\009\009\009\009\009\009end\
\009\009\009\009\009\009\009local value = ParseExpr(scope)\
\009\009\009\009\009\009\009entryList[#entryList+1] = {\
\009\009\009\009\009\009\009\009Type  = 'KeyString',\
\009\009\009\009\009\009\009\009Key   = key.Data,\
\009\009\009\009\009\009\009\009Value = value,\
\009\009\009\009\009\009\009}\
\
\009\009\009\009\009\009else\
\009\009\009\009\009\009\009--we are a value\
\009\009\009\009\009\009\009local value = ParseExpr(scope)\
\009\009\009\009\009\009\009entryList[#entryList+1] = {\
\009\009\009\009\009\009\009\009Type = 'Value',\
\009\009\009\009\009\009\009\009Value = value,\
\009\009\009\009\009\009\009}\
\
\009\009\009\009\009\009end\
\009\009\009\009\009elseif tok.ConsumeSymbol('}', tokenList) then\
\009\009\009\009\009\009break\
\
\009\009\009\009\009else\
\009\009\009\009\009\009--value\
\009\009\009\009\009\009local value = ParseExpr(scope)\
\009\009\009\009\009\009entryList[#entryList+1] = {\
\009\009\009\009\009\009\009Type = 'Value',\
\009\009\009\009\009\009\009Value = value,\
\009\009\009\009\009\009}\
\009\009\009\009\009end\
\
\009\009\009\009\009if tok.ConsumeSymbol(';', tokenList) or tok.ConsumeSymbol(',', tokenList) then\
\009\009\009\009\009\009--all is good\
\009\009\009\009\009elseif tok.ConsumeSymbol('}', tokenList) then\
\009\009\009\009\009\009break\
\009\009\009\009\009else\
\009\009\009\009\009\009GenerateError(\"`}` or table entry Expected\")\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009return v\
\009\009\009end\
\009\009end\
\
\009\009return ParseSuffixedExpr(scope)\
\009end\
\
\009local unopprio = 8\
\009local priority = {\
\009\009['+'] = {6,6},\
\009\009['-'] = {6,6},\
\009\009['%'] = {7,7},\
\009\009['/'] = {7,7},\
\009\009['*'] = {7,7},\
\009\009['^'] = {10,9},\
\009\009['..'] = {5,4},\
\009\009['=='] = {3,3},\
\009\009['<'] = {3,3},\
\009\009['<='] = {3,3},\
\009\009['~='] = {3,3},\
\009\009['>'] = {3,3},\
\009\009['>='] = {3,3},\
\009\009['and'] = {2,2},\
\009\009['or'] = {1,1},\
\009}\
\
\009--- Parse an expression\
\009-- @tparam Skcope.Scope scope The current scope\
\009-- @tparam int level Current level (Optional)\
\009-- @treturn Node The resulting node\
\009function ParseExpr(scope, level)\
\009\009level = level or 0\
\009\009--base item, possibly with unop prefix\
\009\009local exp\
\009\009if unops[tok.Peek().Data] then\
\009\009\009local tokenList = {}\
\009\009\009local op = tok.Get(tokenList).Data\
\009\009\009exp = ParseExpr(scope, unopprio)\
\
\009\009\009local nodeEx = {\
\009\009\009\009AstType = 'UnopExpr',\
\009\009\009\009Rhs     = exp,\
\009\009\009\009Op      = op,\
\009\009\009\009OperatorPrecedence = unopprio,\
\009\009\009\009Tokens  = tokenList,\
\009\009\009}\
\
\009\009\009exp = nodeEx\
\009\009else\
\009\009\009exp = ParseSimpleExpr(scope)\
\009\009end\
\
\009\009--next items in chain\
\009\009while true do\
\009\009\009local prio = priority[tok.Peek().Data]\
\009\009\009if prio and prio[1] > level then\
\009\009\009\009local tokenList = {}\
\009\009\009\009local op = tok.Get(tokenList).Data\
\009\009\009\009local rhs = ParseExpr(scope, prio[2])\
\
\009\009\009\009local nodeEx = {\
\009\009\009\009\009AstType = 'BinopExpr',\
\009\009\009\009\009Lhs     = exp,\
\009\009\009\009\009Op      = op,\
\009\009\009\009\009OperatorPrecedence = prio[1],\
\009\009\009\009\009Rhs     = rhs,\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\
\009\009\009\009exp = nodeEx\
\009\009\009else\
\009\009\009\009break\
\009\009\009end\
\009\009end\
\
\009\009return exp\
\009end\
\
\009--- Parse a statement (if, for, while, etc...)\
\009-- @tparam Scope.Scope scope The current scope\
\009-- @treturn Node The resulting node\
\009local function ParseStatement(scope)\
\009\009local stat = nil\
\009\009local tokenList = {}\
\
\009\009local next = tok.Peek()\
\009\009if next.Type == \"Keyword\" then\
\009\009\009local type = next.Data\
\009\009\009if type == 'if' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009--setup\
\009\009\009\009local clauses = {}\
\009\009\009\009local nodeIfStat = {\
\009\009\009\009\009AstType = 'IfStatement',\
\009\009\009\009\009Clauses = clauses,\
\009\009\009\009}\
\009\009\009\009--clauses\
\009\009\009\009repeat\
\009\009\009\009\009local nodeCond = ParseExpr(scope)\
\
\009\009\009\009\009if not tok.ConsumeKeyword('then', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`then` expected.\")\
\009\009\009\009\009end\
\009\009\009\009\009local nodeBody = ParseStatementList(scope)\
\009\009\009\009\009clauses[#clauses+1] = {\
\009\009\009\009\009\009Condition = nodeCond,\
\009\009\009\009\009\009Body = nodeBody,\
\009\009\009\009\009}\
\009\009\009\009until not tok.ConsumeKeyword('elseif', tokenList)\
\
\009\009\009\009--else clause\
\009\009\009\009if tok.ConsumeKeyword('else', tokenList) then\
\009\009\009\009\009local nodeBody = ParseStatementList(scope)\
\009\009\009\009\009clauses[#clauses+1] = {\
\009\009\009\009\009\009Body = nodeBody,\
\009\009\009\009\009}\
\009\009\009\009end\
\
\009\009\009\009--end\
\009\009\009\009if not tok.ConsumeKeyword('end', tokenList) then\
\009\009\009\009\009GenerateError(\"`end` expected.\")\
\009\009\009\009end\
\
\009\009\009\009nodeIfStat.Tokens = tokenList\
\009\009\009\009stat = nodeIfStat\
\009\009\009elseif type == 'while' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009--condition\
\009\009\009\009local nodeCond = ParseExpr(scope)\
\
\009\009\009\009--do\
\009\009\009\009if not tok.ConsumeKeyword('do', tokenList) then\
\009\009\009\009\009return GenerateError(\"`do` expected.\")\
\009\009\009\009end\
\
\009\009\009\009--body\
\009\009\009\009local nodeBody = ParseStatementList(scope)\
\
\009\009\009\009--end\
\009\009\009\009if not tok.ConsumeKeyword('end', tokenList) then\
\009\009\009\009\009GenerateError(\"`end` expected.\")\
\009\009\009\009end\
\
\009\009\009\009--return\
\009\009\009\009stat = {\
\009\009\009\009\009AstType = 'WhileStatement',\
\009\009\009\009\009Condition = nodeCond,\
\009\009\009\009\009Body      = nodeBody,\
\009\009\009\009\009Tokens    = tokenList,\
\009\009\009\009}\
\009\009\009elseif type == 'do' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009--do block\
\009\009\009\009local nodeBlock = ParseStatementList(scope)\
\009\009\009\009if not tok.ConsumeKeyword('end', tokenList) then\
\009\009\009\009\009GenerateError(\"`end` expected.\")\
\009\009\009\009end\
\
\009\009\009\009stat = {\
\009\009\009\009\009AstType = 'DoStatement',\
\009\009\009\009\009Body    = nodeBlock,\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\009\009\009elseif type == 'for' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009--for block\
\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009GenerateError(\"<ident> expected.\")\
\009\009\009\009end\
\009\009\009\009local baseVarName = tok.Get(tokenList)\
\009\009\009\009if tok.ConsumeSymbol('=', tokenList) then\
\009\009\009\009\009--numeric for\
\009\009\009\009\009local forScope = Scope(scope)\
\009\009\009\009\009local forVar = forScope:CreateLocal(baseVarName.Data)\
\
\009\009\009\009\009local startEx = ParseExpr(scope)\
\009\009\009\009\009if not tok.ConsumeSymbol(',', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`,` Expected\")\
\009\009\009\009\009end\
\009\009\009\009\009local endEx = ParseExpr(scope)\
\009\009\009\009\009local stepEx\
\009\009\009\009\009if tok.ConsumeSymbol(',', tokenList) then\
\009\009\009\009\009\009stepEx = ParseExpr(scope)\
\009\009\009\009\009end\
\009\009\009\009\009if not tok.ConsumeKeyword('do', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`do` expected\")\
\009\009\009\009\009end\
\
\009\009\009\009\009local body = ParseStatementList(forScope)\
\009\009\009\009\009if not tok.ConsumeKeyword('end', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`end` expected\")\
\009\009\009\009\009end\
\
\009\009\009\009\009stat = {\
\009\009\009\009\009\009AstType  = 'NumericForStatement',\
\009\009\009\009\009\009Scope    = forScope,\
\009\009\009\009\009\009Variable = forVar,\
\009\009\009\009\009\009Start    = startEx,\
\009\009\009\009\009\009End      = endEx,\
\009\009\009\009\009\009Step     = stepEx,\
\009\009\009\009\009\009Body     = body,\
\009\009\009\009\009\009Tokens   = tokenList,\
\009\009\009\009\009}\
\009\009\009\009else\
\009\009\009\009\009--generic for\
\009\009\009\009\009local forScope = Scope(scope)\
\
\009\009\009\009\009local varList = { forScope:CreateLocal(baseVarName.Data) }\
\009\009\009\009\009while tok.ConsumeSymbol(',', tokenList) do\
\009\009\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009\009\009GenerateError(\"for variable expected.\")\
\009\009\009\009\009\009end\
\009\009\009\009\009\009varList[#varList+1] = forScope:CreateLocal(tok.Get(tokenList).Data)\
\009\009\009\009\009end\
\009\009\009\009\009if not tok.ConsumeKeyword('in', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`in` expected.\")\
\009\009\009\009\009end\
\009\009\009\009\009local generators = {ParseExpr(scope)}\
\009\009\009\009\009while tok.ConsumeSymbol(',', tokenList) do\
\009\009\009\009\009\009generators[#generators+1] = ParseExpr(scope)\
\009\009\009\009\009end\
\
\009\009\009\009\009if not tok.ConsumeKeyword('do', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`do` expected.\")\
\009\009\009\009\009end\
\
\009\009\009\009\009local body = ParseStatementList(forScope)\
\009\009\009\009\009if not tok.ConsumeKeyword('end', tokenList) then\
\009\009\009\009\009\009GenerateError(\"`end` expected.\")\
\009\009\009\009\009end\
\
\009\009\009\009\009stat = {\
\009\009\009\009\009\009AstType      = 'GenericForStatement',\
\009\009\009\009\009\009Scope        = forScope,\
\009\009\009\009\009\009VariableList = varList,\
\009\009\009\009\009\009Generators   = generators,\
\009\009\009\009\009\009Body         = body,\
\009\009\009\009\009\009Tokens       = tokenList,\
\009\009\009\009\009}\
\009\009\009\009end\
\009\009\009elseif type == 'repeat' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009local body = ParseStatementList(scope)\
\
\009\009\009\009if not tok.ConsumeKeyword('until', tokenList) then\
\009\009\009\009\009GenerateError(\"`until` expected.\")\
\009\009\009\009end\
\
\009\009\009\009local cond = ParseExpr(body.Scope)\
\
\009\009\009\009stat = {\
\009\009\009\009\009AstType   = 'RepeatStatement',\
\009\009\009\009\009Condition = cond,\
\009\009\009\009\009Body      = body,\
\009\009\009\009\009Tokens    = tokenList,\
\009\009\009\009}\
\009\009\009elseif type == 'function' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009GenerateError(\"Function name expected\")\
\009\009\009\009end\
\009\009\009\009local name = ParseSuffixedExpr(scope, true) --true => only dots and colons\
\
\009\009\009\009local func = ParseFunctionArgsAndBody(scope, tokenList)\
\
\009\009\009\009func.IsLocal = false\
\009\009\009\009func.Name    = name\
\009\009\009\009stat = func\
\009\009\009elseif type == 'local' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009if tok.Is('Ident') then\
\009\009\009\009\009local varList = { tok.Get(tokenList).Data }\
\009\009\009\009\009while tok.ConsumeSymbol(',', tokenList) do\
\009\009\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009\009\009GenerateError(\"local var name expected\")\
\009\009\009\009\009\009end\
\009\009\009\009\009\009varList[#varList+1] = tok.Get(tokenList).Data\
\009\009\009\009\009end\
\
\009\009\009\009\009local initList = {}\
\009\009\009\009\009if tok.ConsumeSymbol('=', tokenList) then\
\009\009\009\009\009\009repeat\
\009\009\009\009\009\009\009initList[#initList+1] = ParseExpr(scope)\
\009\009\009\009\009\009until not tok.ConsumeSymbol(',', tokenList)\
\009\009\009\009\009end\
\
\009\009\009\009\009--now patch var list\
\009\009\009\009\009--we can't do this before getting the init list, because the init list does not\
\009\009\009\009\009--have the locals themselves in scope.\
\009\009\009\009\009for i, v in pairs(varList) do\
\009\009\009\009\009\009varList[i] = scope:CreateLocal(v)\
\009\009\009\009\009end\
\
\009\009\009\009\009stat = {\
\009\009\009\009\009\009AstType   = 'LocalStatement',\
\009\009\009\009\009\009LocalList = varList,\
\009\009\009\009\009\009InitList  = initList,\
\009\009\009\009\009\009Tokens    = tokenList,\
\009\009\009\009\009}\
\
\009\009\009\009elseif tok.ConsumeKeyword('function', tokenList) then\
\009\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009\009GenerateError(\"Function name expected\")\
\009\009\009\009\009end\
\009\009\009\009\009local name = tok.Get(tokenList).Data\
\009\009\009\009\009local localVar = scope:CreateLocal(name)\
\
\009\009\009\009\009local func = ParseFunctionArgsAndBody(scope, tokenList)\
\
\009\009\009\009\009func.Name    = localVar\
\009\009\009\009\009func.IsLocal = true\
\009\009\009\009\009stat = func\
\
\009\009\009\009else\
\009\009\009\009\009GenerateError(\"local var or function def expected\")\
\009\009\009\009end\
\009\009\009elseif type == '::' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009GenerateError('Label name expected')\
\009\009\009\009end\
\009\009\009\009local label = tok.Get(tokenList).Data\
\009\009\009\009if not tok.ConsumeSymbol('::', tokenList) then\
\009\009\009\009\009GenerateError(\"`::` expected\")\
\009\009\009\009end\
\009\009\009\009stat = {\
\009\009\009\009\009AstType = 'LabelStatement',\
\009\009\009\009\009Label   = label,\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\009\009\009elseif type == 'return' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009local exList = {}\
\009\009\009\009if not tok.IsKeyword('end') then\
\009\009\009\009\009-- Use PCall as this may produce an error\
\009\009\009\009\009local st, firstEx = pcall(function() return ParseExpr(scope) end)\
\009\009\009\009\009if st then\
\009\009\009\009\009\009exList[1] = firstEx\
\009\009\009\009\009\009while tok.ConsumeSymbol(',', tokenList) do\
\009\009\009\009\009\009\009exList[#exList+1] = ParseExpr(scope)\
\009\009\009\009\009\009end\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009\009stat = {\
\009\009\009\009\009AstType   = 'ReturnStatement',\
\009\009\009\009\009Arguments = exList,\
\009\009\009\009\009Tokens    = tokenList,\
\009\009\009\009}\
\009\009\009elseif type == 'break' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009stat = {\
\009\009\009\009\009AstType = 'BreakStatement',\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\009\009\009elseif type == 'goto' then\
\009\009\009\009tok.Get(tokenList)\
\
\009\009\009\009if not tok.Is('Ident') then\
\009\009\009\009\009GenerateError(\"Label expected\")\
\009\009\009\009end\
\009\009\009\009local label = tok.Get(tokenList).Data\
\009\009\009\009stat = {\
\009\009\009\009\009AstType = 'GotoStatement',\
\009\009\009\009\009Label   = label,\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\009\009\009end\
\009\009end\
\
\009\009if not stat then\
\009\009\009--statementParseExpr\
\009\009\009local suffixed = ParseSuffixedExpr(scope)\
\
\009\009\009--assignment or call?\
\009\009\009if tok.IsSymbol(',') or tok.IsSymbol('=') then\
\009\009\009\009--check that it was not parenthesized, making it not an lvalue\
\009\009\009\009if (suffixed.ParenCount or 0) > 0 then\
\009\009\009\009\009GenerateError(\"Can not assign to parenthesized expression, is not an lvalue\")\
\009\009\009\009end\
\
\009\009\009\009--more processing needed\
\009\009\009\009local lhs = { suffixed }\
\009\009\009\009while tok.ConsumeSymbol(',', tokenList) do\
\009\009\009\009\009lhs[#lhs+1] = ParseSuffixedExpr(scope)\
\009\009\009\009end\
\
\009\009\009\009--equals\
\009\009\009\009if not tok.ConsumeSymbol('=', tokenList) then\
\009\009\009\009\009GenerateError(\"`=` Expected.\")\
\009\009\009\009end\
\
\009\009\009\009--rhs\
\009\009\009\009local rhs = {ParseExpr(scope)}\
\009\009\009\009while tok.ConsumeSymbol(',', tokenList) do\
\009\009\009\009\009rhs[#rhs+1] = ParseExpr(scope)\
\009\009\009\009end\
\
\009\009\009\009--done\
\009\009\009\009stat = {\
\009\009\009\009\009AstType = 'AssignmentStatement',\
\009\009\009\009\009Lhs     = lhs,\
\009\009\009\009\009Rhs     = rhs,\
\009\009\009\009\009Tokens  = tokenList,\
\009\009\009\009}\
\
\009\009\009elseif suffixed.AstType == 'CallExpr' or\
\009\009\009\009   suffixed.AstType == 'TableCallExpr' or\
\009\009\009\009   suffixed.AstType == 'StringCallExpr'\
\009\009\009then\
\009\009\009\009--it's a call statement\
\009\009\009\009stat = {\
\009\009\009\009\009AstType    = 'CallStatement',\
\009\009\009\009\009Expression = suffixed,\
\009\009\009\009\009Tokens     = tokenList,\
\009\009\009\009}\
\009\009\009else\
\009\009\009\009GenerateError(\"Assignment Statement Expected\")\
\009\009\009end\
\009\009end\
\
\009\009if tok.IsSymbol(';') then\
\009\009\009stat.Semicolon = tok.Get( stat.Tokens )\
\009\009end\
\009\009return stat\
\009end\
\
\009--- Parse a a list of statements\
\009-- @tparam Scope.Scope scope The current scope\
\009-- @treturn Node The resulting node\
\009function ParseStatementList(scope)\
\009\009local body = {}\
\009\009local nodeStatlist   = {\
\009\009\009Scope   = Scope(scope),\
\009\009\009AstType = 'Statlist',\
\009\009\009Body    = body,\
\009\009\009Tokens  = {},\
\009\009}\
\
\009\009while not statListCloseKeywords[tok.Peek().Data] and not tok.IsEof() do\
\009\009\009local nodeStatement = ParseStatement(nodeStatlist.Scope)\
\009\009\009--stats[#stats+1] = nodeStatement\
\009\009\009body[#body + 1] = nodeStatement\
\009\009end\
\
\009\009if tok.IsEof() then\
\009\009\009local nodeEof = {}\
\009\009\009nodeEof.AstType = 'Eof'\
\009\009\009nodeEof.Tokens  = { tok.Get() }\
\009\009\009body[#body + 1] = nodeEof\
\009\009end\
\
\009\009--nodeStatlist.Body = stats\
\009\009return nodeStatlist\
\009end\
\
\009return ParseStatementList(Scope())\
end\
\
--- @export\
return { LexLua = LexLua, ParseLua = ParseLua }\
end\
preload[\"howl.lexer.constants\"] = function(...)\
--- Lexer constants\
-- @module howl.lexer.constants\
\
local function createLookup(tbl)\
\009for k,v in ipairs(tbl) do tbl[v] = k end\
\009return tbl\
end\
\
return {\
\009--- List of white chars\
\009WhiteChars = createLookup { ' ', '\\n', '\\t', '\\r' },\
\
\009--- Lookup of escape characters\
\009EscapeLookup = { ['\\r'] = '\\\\r', ['\\n'] = '\\\\n', ['\\t'] = '\\\\t', ['\"'] = '\\\\\"', [\"'\"] = \"\\\\'\" },\
\
\009--- Lookup of lower case characters\
\009LowerChars = createLookup {\
\009\009'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
\009\009'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\
\009},\
\
\009--- Lookup of upper case characters\
\009UpperChars = createLookup {\
\009\009'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
\009\009'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\
\009},\
\
\009--- Lookup of digits\
\009Digits = createLookup { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' },\
\
\009--- Lookup of hex digits\
\009HexDigits = createLookup {\
\009\009'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\
\009\009'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f'\
\009},\
\
\009--- Lookup of valid symbols\
\009Symbols = createLookup { '+', '-', '*', '/', '^', '%', ',', '{', '}', '[', ']', '(', ')', ';', '#' },\
\
\009--- Lookup of valid keywords\
\009Keywords = createLookup {\
\009\009'and', 'break', 'do', 'else', 'elseif',\
\009\009'end', 'false', 'for', 'function', 'goto', 'if',\
\009\009'in', 'local', 'nil', 'not', 'or', 'repeat',\
\009\009'return', 'then', 'true', 'until', 'while',\
\009},\
\
\009--- Keywords that end a block\
\009StatListCloseKeywords = createLookup { 'end', 'else', 'elseif', 'until' },\
\
\009--- Unary operators\
\009UnOps = createLookup { '-', 'not', '#' },\
}\
end\
preload[\"howl.files.Source\"] = function(...)\
--- A source location for a series of files.\
-- This holds a list of inclusion and exclusion filters.\
-- @classmod howl.files.Source\
\
local assert = require \"howl.lib.assert\"\
local class = require \"howl.class\"\
local matcher = require \"howl.files.matcher\"\
local mixin = require \"howl.class.mixin\"\
local fs = require \"howl.platform\".fs\
\
local insert = table.insert\
\
local Source = class(\"howl.files.Source\")\
\009:include(mixin.configurable)\
\009:include(mixin.filterable)\
\
local function extractPattern(item)\
\009local t = type(item)\
\009if t == \"function\" or t == \"string\" then\
\009\009return matcher.createMatcher(item)\
\009elseif t == \"table\" and item.tag and item.predicate then\
\009\009return item\
\009elseif t == \"table\" and item.isInstanceOf and item:isInstanceOf(Source) then\
\009\009return matcher.createMatcher(function(text) return item:matches(text) end)\
\009else\
\009\009return nil\
\009end\
end\
\
local function append(destination, source, func, i)\
\009local extracted = extractPattern(source)\
\009local t = type(source)\
\009if extracted then\
\009\009insert(destination, extracted)\
\009elseif t == \"table\" then\
\009\009for i, item in ipairs(source) do\
\009\009\009local extracted = extractPattern(item)\
\009\009\009if extracted then\
\009\009\009\009insert(destination, extracted)\
\009\009\009else\
\009\009\009\009error(\"bad item #\" .. i .. \" for \" .. func .. \" (expected pattern, got \" .. type(item) .. \")\")\
\009\009\009end\
\009\009end\
\009else\
\009\009error(\"bad argument #\" .. i .. \" for \" .. func .. \" (expected pattern, got \" .. t .. \")\")\
\009end\
end\
\
local function matches(items, text)\
\009for _, pattern in pairs(items) do\
\009\009if pattern:match(text) then\
\009\009\009return true\
\009\009end\
\009end\
\
\009return false\
end\
\
function Source:initialize(allowEmpty, parent)\
\009if allowEmpty == nil then allowEmpty = true end\
\
\009self.parent = parent\
\009self.children = {}\
\
\009self.includes = {}\
\009self.excludes = {}\
\009self.allowEmpty = allowEmpty\
end\
\
function Source:from(path, configure)\
\009assert.argType(path, \"string\", \"from\", 1)\
\009path = fs.normalise(path)\
\
\009local source = self.children[path]\
\009if not source then\
\009\009source = self.class(true, self)\
\009\009self.children[path] = source\
\009\009self.allowEmpty = false\
\009end\
\
\009if configure ~= nil then\
\009\009return source:configureWith(configure)\
\009else\
\009\009return source\
\009end\
end\
\
function Source:include(...)\
\009local n = select('#', ...)\
\009local args = {...}\
\009for i = 1, n do\
\009\009append(self.includes, args[i], \"include\", i)\
\009end\
\
\009return self\
end\
\
function Source:exclude(...)\
\009local n = select('#', ...)\
\009local args = {...}\
\009for i = 1, n do\
\009\009append(self.excludes, args[i], \"exclude\", i)\
\009end\
\
\009return self\
end\
\
function Source:excluded(text)\
\009if matches(self.excludes, text) then\
\009\009return true\
\009elseif self.parent then\
\009\009-- FIXME: Combine this path\
\009\009return self.parent:excluded(text)\
\009else\
\009\009return false\
\009end\
end\
\
function Source:included(text)\
\009if #self.includes == 0 then\
\009\009return self.allowEmpty\
\009else\
\009\009return matches(self.includes, text)\
\009end\
end\
\
function Source:configure(item)\
\009assert.argType(item, \"table\", \"configure\", 1)\
\009-- TODO: Ensure other keys aren't passed\
\009-- TODO: Fix passing other source instances\
\
\009if item.include ~= nil then self:include(item.include) end\
\009if item.exclude ~= nil then self:exclude(item.exclude) end\
\
\009if item.with ~= nil then\
\009\009assert.type(item.with, \"table\", \"expected table for with, got %s\")\
\009\009for _, v in ipairs(item.with) do\
\009\009\009self:with(v)\
\009\009end\
\009end\
end\
\
function Source:matches(text)\
\009return self:included(text) and not self:excluded(text)\
end\
\
function Source:hasFiles()\
\009if self.allowEmpty or #self.includes > 0 then return true end\
\009for _, source in pairs(self.children) do\
\009\009if source:hasFiles() then return true end\
\009end\
\009return false\
end\
\
function Source:gatherFiles(root, includeDirectories, outList)\
\009if not outList then outList = {} end\
\
\009for dir, source in pairs(self.children) do\
\009\009local path = fs.combine(root, dir)\
\009\009source:gatherFiles(path, includeDirectories, outList)\
\009end\
\
\009if self.allowEmpty or #self.includes > 0 then\
\009\009-- I lied. Its a stack\
\009\009local queue, queueN = { root }, 1\
\
\009\009local n = #outList\
\009\009while queueN > 0 do\
\009\009\009local path = queue[queueN]\
\009\009\009local relative = path\
\009\009\009if root ~= \"\" then relative = relative:sub(#root + 2) end\
\009\009\009queueN = queueN - 1\
\
\009\009\009if fs.isDir(path) then\
\009\009\009\009if not self:excluded(relative) then\
\009\009\009\009\009if includeDirectories and self:included(relative) then\
\009\009\009\009\009\009n = n + 1\
\009\009\009\009\009\009outList[n] = self:buildFile(path, relative)\
\009\009\009\009\009end\
\
\009\009\009\009\009for _, v in ipairs(fs.list(path)) do\
\009\009\009\009\009\009queueN = queueN + 1\
\009\009\009\009\009\009queue[queueN] = fs.combine(path, v)\
\009\009\009\009\009end\
\009\009\009\009end\
\009\009\009elseif self:included(relative) and not self:excluded(relative) then\
\009\009\009\009n = n + 1\
\009\009\009\009outList[n] = self:buildFile(path, relative)\
\009\009\009end\
\009\009end\
\009end\
\
\009return outList\
end\
\
function Source:buildFile(path, relative)\
\009return {\
\009\009path = path,\
\009\009relative = relative,\
\009\009name = relative,\
\009}\
end\
\
return Source\
end\
preload[\"howl.files.matcher\"] = function(...)\
--- Used to create matchers for particular patterns\
-- @module howl.files.matcher\
\
local utils = require \"howl.lib.utils\"\
\
-- Matches with * and ?  removed\
local basicMatches = {\
\009[\"^\"] = \"%^\", [\"$\"] = \"%$\", [\"(\"] = \"%(\", [\")\"] = \"%)\",\
\009[\"%\"] = \"%%\", [\".\"] = \"%.\", [\"[\"] = \"%[\", [\"]\"] = \"%]\",\
\009[\"+\"] = \"%+\", [\"-\"] = \"%-\", [\"\\0\"] = \"%z\",\
}\
\
local wildMatches = {\
\009-- [\"*\"] = \"([^\\\\]+)\",\
\009-- [\"?\"] = \"([^\\\\])\",\
\009[\"*\"] = \"(.*)\"\
}\
for k,v in pairs(basicMatches) do wildMatches[k] = v end\
\
--- A resulting pattern\
-- @table Pattern\
-- @tfield string tag `pattern` or `normal`\
-- @tfield (Pattern, string)->boolean match Predicate to check if this is a valid item\
\
local function patternAction(self, text) return text:match(self.text) end\
local function textAction(self, text)\
\009return self.text == \"\" or self.text == text or text:sub(1, #self.text + 1) == self.text .. \"/\"\
end\
local function funcAction(self, text) return self.func(text) end\
\
--- Create a matcher\
-- @tparam string|function pattern Pattern to check against\
-- @treturn Pattern\
local function createMatcher(pattern)\
\009local t = type(pattern)\
\009if t == \"string\" then\
\009\009local remainder = utils.startsWith(pattern, \"pattern:\") or utils.startsWith(pattern, \"ptrn:\")\
\009\009if remainder then\
\009\009\009return { tag = \"pattern\", text = remainder, match = patternAction }\
\009\009end\
\
\009\009if pattern:find(\"%*\") then\
\009\009\009local pattern = \"^\" .. pattern:gsub(\".\", wildMatches) .. \"$\"\
\009\009\009return { tag = \"pattern\", text = pattern, match = patternAction }\
\009\009end\
\
\009\009return { tag = \"text\", text = pattern, match = textAction}\
\009elseif t == \"function\" or (t == \"table\" and (getmetatable(pattern) or {}).__call) then\
\009\009return { tag = \"function\", func = pattern, match = funcAction }\
\009else\
\009\009error(\"Expected string or function\")\
\009end\
end\
\
\
return {\
\009createMatcher = createMatcher,\
}\
end\
preload[\"howl.files.CopySource\"] = function(...)\
--- A source location for a series of files.\
-- This holds a list of inclusion and exclusion filters.\
-- @classmod howl.files.Source\
\
local assert = require \"howl.lib.assert\"\
local matcher = require \"howl.files.matcher\"\
local mixin = require \"howl.class.mixin\"\
local fs = require \"howl.platform\".fs\
\
local Source = require \"howl.files.Source\"\
\
local insert = table.insert\
\
local CopySource = Source:subclass(\"howl.files.CopySource\")\
\
function CopySource:initialize(allowEmpty, parent)\
\009Source.initialize(self, allowEmpty, parent)\
\
\009self.renames = {}\
\009self.modifiers = {}\
end\
\
function CopySource:configure(item)\
\009assert.argType(item, \"table\", \"configure\", 1)\
\009Source.configure(self, item)\
\
\009if item.rename ~= nil then self:rename(item.rename) end\
\009if item.modify ~= nil then self:modify(item.modify) end\
end\
\
function CopySource:rename(from, to)\
\009local tyFrom, tyTo = type(from), type(to)\
\009if tyFrom == \"table\" and to == nil then\
\009\009for _, v in ipairs(from) do\
\009\009\009self:rename(v)\
\009\009end\
\009elseif tyFrom == \"function\" and to == nil then\
\009\009insert(self.renames, from)\
\009elseif tyFrom == \"string\" and tyTo == \"string\" then\
\009\009insert(self.renames, function(file)\
\009\009\009return (file.name:gsub(from, to))\
\009\009end)\
\009else\
\009\009error(\"bad arguments for rename (expected table, function or string, string pair, got \" .. tyFrom .. \" and \" .. tyTo .. \")\", 2)\
\009end\
end\
\
\
function CopySource:modify(modifier)\
\009local ty = type(modifier)\
\009if ty == \"table\" then\
\009\009for _, v in ipairs(modifier) do\
\009\009\009self:modify(v)\
\009\009end\
\009elseif ty == \"function\" then\
\009\009insert(self.modifiers, modifier)\
\009else\
\009\009error(\"bad argument #1 for modify (expected table or function, got \" .. ty .. \")\", 2)\
\009end\
end\
\
function CopySource:doMutate(file)\
\009for _, modifier in ipairs(self.modifiers) do\
\009\009local contents = modifier(file)\
\009\009if contents then file.contents = contents end\
\009end\
\
\009for _, renamer in ipairs(self.renames) do\
\009\009local name = renamer(file)\
\009\009if name then file.name = name end\
\009end\
\
\009if self.parent then\
\009\009return self.parent:doMutate(file)\
\009else\
\009\009return file\
\009end\
end\
\
function CopySource:buildFile(path, relative)\
\009return self:doMutate {\
\009\009path = path,\
\009\009relative = relative,\
\009\009name = relative,\
\009\009contents = fs.read(path),\
\009}\
end\
\
return CopySource\
end\
preload[\"howl.context\"] = function(...)\
--- Handles the whole Howl instance\
-- @classmod howl.Context\
\
local assert = require \"howl.lib.assert\"\
local class = require \"howl.class\"\
local mixin = require \"howl.class.mixin\"\
local mediator = require \"howl.lib.mediator\"\
local argparse = require \"howl.lib.argparse\"\
\
local Logger = require \"howl.lib.Logger\"\
local Manager = require \"howl.packages.Manager\"\
\
local Context = class(\"howl.Context\"):include(mixin.sealed)\
\
--- Setup the main context\
-- @tparam string root The project root of the directory\
-- @tparam howl.lib.argparse args The argument parser\
function Context:initialize(root, args)\
\009assert.type(root, \"string\", \"bad argument #1 for Context expected string, got %s\")\
\009assert.type(args, \"table\", \"bad argument #2 for Context expected table, got %s\")\
\
\009self.root = root\
\009self.out = \"build\"\
\009self.mediator = mediator\
\009self.arguments = argparse.Options(self.mediator, args)\
\009self.logger = Logger(self)\
\009self.packageManager = Manager(self)\
\009self.modules = {}\
end\
\
--- Include a module in this context\
-- @tparam string|table The module to include\
function Context:include(module)\
\009if type(module) ~= \"table\" then\
\009\009module = require(module)\
\009end\
\
\009if self.modules[module.name] then\
\009\009self.logger:warn(module.name .. \" already included, skipping\")\
\009\009return\
\009end\
\
\009local data = { module = module, }\
\009self.modules[module.name] = data\
\
\009self.logger:verbose(\"Including \" .. module.name .. \": \" .. module.description)\
\
\009if not module.applied then\
\009\009module.applied = true\
\009\009if module.apply then module.apply() end\
\009end\
\
\009if module.setup then module.setup(self, data) end\
end\
\
function Context:getModuleData(name)\
\009return self.modules[name]\
end\
\
return Context\
end\
preload[\"howl.cli\"] = function(...)\
--- Core script for Howl\
-- @script howl.cli\
\
local loader = require \"howl.loader\"\
local colored = require \"howl.lib.colored\"\
local fs = require \"howl.platform\".fs\
\
local howlFile, currentDirectory = loader.FindHowl()\
-- TODO: Don't pass the error message as the current directory: construct mediator/arg parser another time.\
local context = require \"howl.context\"(currentDirectory or fs.currentDir(), {...})\
\
local options = context.arguments\
\
options\
\009:Option \"verbose\"\
\009:Alias \"v\"\
\009:Description \"Print verbose output\"\
options\
\009:Option \"time\"\
\009:Alias \"t\"\
\009:Description \"Display the time taken for tasks\"\
options\
\009:Option \"trace\"\
\009:Description \"Print a stack trace on errors\"\
options\
\009:Option \"help\"\
\009:Alias \"?\"\
\009:Alias \"h\"\
\009:Description \"Print this help\"\
\
context:include \"howl.modules.dependencies.file\"\
context:include \"howl.modules.dependencies.task\"\
context:include \"howl.modules.list\"\
context:include \"howl.modules.plugins\"\
context:include \"howl.modules.packages.file\"\
context:include \"howl.modules.packages.gist\"\
context:include \"howl.modules.packages.pastebin\"\
context:include \"howl.modules.tasks.clean\"\
context:include \"howl.modules.tasks.gist\"\
context:include \"howl.modules.tasks.minify\"\
context:include \"howl.modules.tasks.pack\"\
context:include \"howl.modules.tasks.require\"\
\
-- Setup Tasks\
local taskList = options:Arguments()\
local function setHelp()\
\009if options:Get \"help\" then\
\009\009taskList = { \"help\" }\
\009end\
end\
context.mediator:subscribe({ \"ArgParse\", \"changed\" }, setHelp)\
setHelp()\
\
-- Locate the howl file\
if not howlFile then\
\009if #taskList == 1 and taskList[1] == \"help\" then\
\009\009colored.writeColor(\"yellow\", \"Howl\")\
\009\009colored.printColor(\"lightGrey\", \" is a simple build system for Lua\")\
\009\009colored.printColor(\"grey\", \"You can read the full documentation online: https://github.com/SquidDev-CC/Howl/wiki/\")\
\
\009\009colored.printColor(\"white\", (([[\
\009\009\009The key thing you are missing is a HowlFile. This can be \"Howlfile\" or \"Howlfile.lua\".\
\009\009\009Then you need to define some tasks. Maybe something like this:\
\009\009]]):gsub(\"\\t\", \"\"):gsub(\"\\n+$\", \"\")))\
\
\009\009colored.printColor(\"magenta\", 'Tasks:minify \"minify\" {')\
\009\009colored.printColor(\"magenta\", '  input = \"build/Howl.lua\",')\
\009\009colored.printColor(\"magenta\", '  output = \"build/Howl.min.lua\",')\
\009\009colored.printColor(\"magenta\", '}')\
\
\009\009colored.printColor(\"white\", \"Now just run '\" .. fs.getName(fs.currentProgram()) .. \" minify'!\")\
\
\009\009colored.printColor(\"orange\", \"\\nOptions:\")\
\009\009options:Help(\"  \")\
\009elseif #taskList == 0 then\
\009\009error(currentDirectory .. \" Use \" .. fs.getName(fs.currentProgram()) .. \" --help to dislay usage.\", 0)\
\009else\
\009\009error(currentDirectory, 0)\
\009end\
\
\009return\
end\
\
context.logger:verbose(\"Found HowlFile at \" .. fs.combine(currentDirectory, howlFile))\
\
local tasks, environment = loader.SetupTasks(context, howlFile)\
\
-- Basic list tasks\
tasks:Task \"list\" (function()\
\009tasks:listTasks()\
end):description \"Lists all the tasks\"\
\
tasks:Task \"help\" (function()\
\009print(\"Howl [options] [task]\")\
\009colored.printColor(\"orange\", \"Tasks:\")\
\009tasks:listTasks(\"  \")\
\
\009colored.printColor(\"orange\", \"\\nOptions:\")\
\009options:Help(\"  \")\
end):description \"Print out a detailed usage for Howl\"\
\
-- If no other task exists run this\
tasks:Default(function()\
\009context.logger:error(\"No default task exists.\")\
\009context.logger:verbose(\"Use 'Tasks:Default' to define a default task\")\
\009colored.printColor(\"orange\", \"Choose from: \")\
\009tasks:listTasks(\"  \")\
end)\
\
environment.dofile(fs.combine(currentDirectory, howlFile))\
\
if not tasks:setup() then\
\009error(\"Error setting up tasks\", 0)\
end\
\
-- Run the task\
if not tasks:RunMany(taskList) then\
\009error(\"Error running tasks\", 0)\
end\
end\
preload[\"howl.class.mixin\"] = function(...)\
--- Various mixins for the class library\
-- @module howl.class.mixin\
\
local assert = require \"howl.lib.assert\"\
local rawset = rawset\
\
local mixins = {}\
\
--- Prevent subclassing a class\
mixins.sealed = {\
\009static = {\
\009\009subclass = function(self, name)\
\009\009\009assert(type(self) == 'table', \"Make sure that you are using 'Class:subclass' instead of 'Class.subclass'\")\
\009\009\009assert(type(name) == \"string\", \"You must provide a name(string) for your class\")\
\009\009\009error(\"Cannot subclass '\" .. tostring(self) .. \"' (attempting to create '\" .. name .. \"')\", 2)\
\009\009end,\
\009}\
}\
\
mixins.curry = {\
\009curry = function(self, name)\
\009\009assert.type(self, \"table\", \"Bad argument #1 to class:curry (expected table, got %s)\")\
\009\009assert.type(name, \"string\", \"Bad argument #2 to class:curry (expected string, got %s)\")\
\009\009local func = self[name]\
\009\009assert.type(func, \"function\", \"No such function \" .. name)\
\009\009return function(...) return func(self, ...) end\
\009end,\
\
\009__div = function(self, name) return self:curry(name) end,\
}\
\
mixins.configurable = {\
\009configureWith = function(self, arg)\
\009\009local t = type(arg)\
\009\009if t == \"table\" then\
\009\009\009self:configure(arg)\
\009\009\009return self\
\009\009elseif t == \"function\" then\
\009\009\009arg(self)\
\009\009\009return self\
\009\009else\
\009\009\009error(\"Expected table or function, got \" .. type(arg), 2)\
\009\009end\
\
\009\009return self\
\009end,\
\
\009__call = function(self, ...) return self:configureWith(...) end,\
}\
\
mixins.filterable = {\
\009__add = function(self, ...) return self:include(...) end,\
\009__sub = function(self, ...) return self:exclude(...) end,\
\009with = function(self, ...) return self:configure(...) end,\
}\
\
function mixins.delegate(name, keys)\
\009local out = {}\
\009for _, key in ipairs(keys) do\
\009\009out[key] = function(self, ...)\
\009\009\009local object = self[name]\
\009\009\009return object[key](object, ...)\
\009\009end\
\009end\
\
\009return out\
end\
\
mixins.optionGroup = {\
\009static = {\
\009\009addOption = function(self, key)\
\009\009\009local func = function(self, value)\
\009\009\009\009if value == nil then value = true end\
\009\009\009\009self.options[key] = value\
\009\009\009\009return self\
\009\009\009end\
\
\009\009\009self[key:gsub(\"^%l\", string.upper)] = func\
\009\009\009self[key] = func\
\
\009\009\009if not rawget(self.static, \"options\") then\
\009\009\009\009local options = {}\
\009\009\009\009self.static.options = options\
\009\009\009\009local parent = self.super and self.super.static.options\
\
\009\009\009\009-- TODO: Copy instead. Also propagate to children below\
\009\009\009\009if parent then setmetatable(options, { __index = parent } ) end\
\009\009\009end\
\
\009\009\009self.static.options[key] = true\
\
\009\009\009return self\
\009\009end,\
\009\009addOptions = function(self, names)\
\009\009\009for i = 1, #names do\
\009\009\009\009self:addOption(names[i])\
\009\009\009end\
\
\009\009\009return self\
\009\009end,\
\009},\
\
\009configure = function(self, item)\
\009\009assert.argType(item, \"table\", \"configure\", 1)\
\
\009\009local class = self.class\
\009\009local options = class.options\
\009\009while class and not options do\
\009\009\009options = class.options\
\009\009\009class = class.super\
\009\009end\
\
\009\009if not options then return end\
\
\009\009for k, v in pairs(item) do\
\009\009\009if options[k] then\
\009\009\009\009self[k](self, v)\
\009\009\009end\
\009\009end\
\009end,\
\
\009__newindex = function(self, key, value)\
\009\009if self.class.options and self.class.options[key] then -- TODO: This is being applied to superclasses\
\009\009\009self[key](self, value)\
\009\009else\
\009\009\009rawset(self, key, value)\
\009\009end\
\009end\
}\
\
return mixins\
end\
preload[\"howl.class\"] = function(...)\
--- An OOP library for Lua\
-- @module howl.class\
\
local middleclass = {\
\009_VERSION     = 'middleclass v4.0.0',\
\009_DESCRIPTION = 'Object Orientation for Lua',\
\009_URL         = 'https://github.com/kikito/middleclass',\
\009_LICENSE     = [[\
\009\009MIT LICENSE\
\
\009\009Copyright (c) 2011 Enrique Garca Cota\
\
\009\009Permission is hereby granted, free of charge, to any person obtaining a\
\009\009copy of this software and associated documentation files (the\
\009\009\"Software\"), to deal in the Software without restriction, including\
\009\009without limitation the rights to use, copy, modify, merge, publish,\
\009\009distribute, sublicense, and/or sell copies of the Software, and to\
\009\009permit persons to whom the Software is furnished to do so, subject to\
\009\009the following conditions:\
\
\009\009The above copyright notice and this permission notice shall be included\
\009\009in all copies or substantial portions of the Software.\
\
\009\009THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\
\009\009OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\
\009\009MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\
\009\009IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\
\009\009CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\
\009\009TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\
\009\009SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\
\009]]\
}\
\
local function _createIndexWrapper(aClass, f)\
\009if f == nil then\
\009\009return aClass.__instanceDict\
\009else\
\009\009return function(self, name)\
\009\009\009local value = aClass.__instanceDict[name]\
\
\009\009\009if value ~= nil then\
\009\009\009\009return value\
\009\009\009elseif type(f) == \"function\" then\
\009\009\009\009return (f(self, name))\
\009\009\009else\
\009\009\009\009return f[name]\
\009\009\009end\
\009\009end\
\009end\
end\
\
local function _propagateInstanceMethod(aClass, name, f)\
\009f = name == \"__index\" and _createIndexWrapper(aClass, f) or f\
\009aClass.__instanceDict[name] = f\
\
\009for subclass in pairs(aClass.subclasses) do\
\009\009if rawget(subclass.__declaredMethods, name) == nil then\
\009\009\009_propagateInstanceMethod(subclass, name, f)\
\009\009end\
\009end\
end\
\
local function _declareInstanceMethod(aClass, name, f)\
\009aClass.__declaredMethods[name] = f\
\
\009if f == nil and aClass.super then\
\009\009f = aClass.super.__instanceDict[name]\
\009end\
\
\009_propagateInstanceMethod(aClass, name, f)\
end\
\
local function _tostring(self) return \"class \" .. self.name end\
local function _call(self, ...) return self:new(...) end\
\
local function _createClass(name, super)\
\009local dict = {}\
\009dict.__index = dict\
\
\009local aClass = {\
\009\009name = name, super = super, static = {},\
\009\009__instanceDict = dict, __declaredMethods = {},\
\009\009subclasses = setmetatable({}, {__mode='k'})\
\009}\
\
\009if super then\
\009\009setmetatable(aClass.static, { __index = function(_,k) return rawget(dict,k) or super.static[k] end })\
\009else\
\009\009setmetatable(aClass.static, { __index = function(_,k) return rawget(dict,k) end })\
\009end\
\
\009setmetatable(aClass, {\
\009\009__index = aClass.static, __tostring = _tostring,\
\009\009__call = _call, __newindex = _declareInstanceMethod\
\009})\
\
\009return aClass\
end\
\
local function _includeMixin(aClass, mixin)\
\009assert(type(mixin) == 'table', \"mixin must be a table\")\
\
\009for name,method in pairs(mixin) do\
\009\009if name ~= \"included\" and name ~= \"static\" then aClass[name] = method end\
\009end\
\
\009for name,method in pairs(mixin.static or {}) do\
\009\009aClass.static[name] = method\
\009end\
\
\009if type(mixin.included)==\"function\" then mixin:included(aClass) end\
\009return aClass\
end\
\
local DefaultMixin = {\
\009__tostring   = function(self) return \"instance of \" .. tostring(self.class) end,\
\
\009initialize   = function(self, ...) end,\
\
\009isInstanceOf = function(self, aClass)\
\009\009return\
\009\009\009type(self)       == 'table' and\
\009\009\009type(self.class) == 'table' and\
\009\009\009type(aClass)     == 'table' and\
\009\009\009( aClass == self.class or\
\009\009\009\009type(aClass.isSubclassOf) == 'function' and\
\009\009\009\009self.class:isSubclassOf(aClass)\
\009\009\009)\
\009end,\
\
\009static = {\
\009\009allocate = function(self)\
\009\009\009assert(type(self) == 'table', \"Make sure that you are using 'Class:allocate' instead of 'Class.allocate'\")\
\009\009\009return setmetatable({ class = self }, self.__instanceDict)\
\009\009end,\
\
\009\009new = function(self, ...)\
\009\009\009assert(type(self) == 'table', \"Make sure that you are using 'Class:new' instead of 'Class.new'\")\
\009\009\009local instance = self:allocate()\
\009\009\009instance:initialize(...)\
\009\009\009return instance\
\009\009end,\
\
\009\009subclass = function(self, name)\
\009\009\009assert(type(self) == 'table', \"Make sure that you are using 'Class:subclass' instead of 'Class.subclass'\")\
\009\009\009assert(type(name) == \"string\", \"You must provide a name(string) for your class\")\
\
\009\009\009local subclass = _createClass(name, self)\
\
\009\009\009for methodName, f in pairs(self.__instanceDict) do\
\009\009\009\009_propagateInstanceMethod(subclass, methodName, f)\
\009\009\009end\
\009\009\009subclass.initialize = function(instance, ...) return self.initialize(instance, ...) end\
\
\009\009\009self.subclasses[subclass] = true\
\009\009\009self:subclassed(subclass)\
\
\009\009\009return subclass\
\009\009end,\
\
\009\009subclassed = function(self, other) end,\
\
\009\009isSubclassOf = function(self, other)\
\009\009\009return\
\009\009\009\009type(other)      == 'table' and\
\009\009\009\009type(self)       == 'table' and\
\009\009\009\009type(self.super) == 'table' and\
\009\009\009\009(self.super == other or\
\009\009\009\009\009type(self.super.isSubclassOf) == 'function' and\
\009\009\009\009\009self.super:isSubclassOf(other) )\
\009\009end,\
\
\009\009include = function(self, ...)\
\009\009\009assert(type(self) == 'table', \"Make sure you that you are using 'Class:include' instead of 'Class.include'\")\
\009\009\009for _,mixin in ipairs({...}) do _includeMixin(self, mixin) end\
\009\009\009return self\
\009\009end\
\009}\
}\
\
return function(name, super)\
\009assert(type(name) == 'string', \"A name (string) is needed for the new class\")\
\009return super and super:subclass(name) or _includeMixin(_createClass(name), DefaultMixin)\
end\
end\
if not shell or type(... or nil) == 'table' then\
local tbl = ... or {}\
tbl.require = require tbl.preload = preload\
return tbl\
else\
return preload[\"howl.cli\"](...)\
end",
  },
  {
    "installer",
    "if fs.exists(\"/howl\") then\
print(\"Howl has succesfully been installed!\")\
else\
print(\"Something went wrong during installation of howl!\")\
end",
  },
  meta = {
    dependencies = "none",
    info = "Howl is a lua build system\
\
Features\
Combine multiple files into one single executable\
Minify lua files\
Support for Oeed's Compilr\
Integration with the Busted testing framework\
Large portions work in normal Lua",
  },
}
